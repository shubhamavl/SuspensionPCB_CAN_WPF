using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Threading;
using System.Windows.Media;
using System.IO;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Windows.Input;
using System.Windows.Controls;
using System.Threading.Tasks;

namespace SuspensionPCB_CAN_WPF
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private DispatcherTimer? _uiUpdateTimer;
        private DispatcherTimer? _autoRequestTimer;
        private DispatcherTimer? _clockTimer;

        private volatile int _totalMessages, _txMessages, _rxMessages;
        private readonly object _dataLock = new object();
        private CANService? _canService;  // Changed from USBCANManager to CANService
        private readonly object _statisticsLock = new object();

        // Add calibration state fields
        private int _expectedCalibrationPoints = 0;
        private int _receivedAutoGeneratedPoints = 0;
        private List<CalibrationPointData> _autoGeneratedPoints = new List<CalibrationPointData>();

        // Suspension system weight data (protocol v0.5 format)
        private SuspensionWeightData _suspensionWeights = new SuspensionWeightData();
        private AxleWeightData _axleWeights = new AxleWeightData();
        private CalibrationData _calibrationData = new CalibrationData();

        // Thread-safe collections for better performance
        private readonly ConcurrentQueue<CANMessageViewModel> _messageQueue = new ConcurrentQueue<CANMessageViewModel>();
        public ObservableCollection<CANMessageViewModel> Messages { get; set; } = new ObservableCollection<CANMessageViewModel>();
        public ObservableCollection<CANMessageViewModel> FilteredMessages { get; set; } = new ObservableCollection<CANMessageViewModel>();

        // Updated message IDs according to CAN Protocol Specification v0.5 - Suspension System Only
        private readonly HashSet<uint> _rxMessageIds = new HashSet<uint> {
            0x200,  // Suspension weight data response
            0x201,  // Axle weight data response
            0x400,  // Variable calibration data response
            0x401,  // Calibration quality analysis response
            0x402,  // Error response system
            0x500   // System status summary
        };

        private readonly HashSet<uint> _txMessageIds = new HashSet<uint> {
            0x000, 0x001,               // Emergency commands
            0x020, 0x022, 0x023, 0x024, // Variable multi-point calibration commands
            0x025, 0x026, 0x027,        // Flash storage and load cell commands
            0x030, 0x031                // Data request commands (suspension & axle only)
        };

        // Current transmission state
        private byte _currentTransmissionRate = 3; // Default 500Hz

        // v0.7 Calibration and Tare functionality
        private LinearCalibration? _leftCalibration;
        private LinearCalibration? _rightCalibration;
        private TareManager _tareManager = new TareManager();
        private DataLogger _dataLogger = new DataLogger();
        
        // Current raw ADC data (from STM32)
        private int _leftRawADC = 0;
        private int _rightRawADC = 0;

        public MainWindow()
        {
            InitializeComponent();
            this.DataContext = this;
            InitializeApplication();
        }

        private void StopAll_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // Change to loading state
                StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(255, 193, 7)); // Yellow
                StopAllBtn.Content = "Stopping...";

                // Use v0.7 semantic stream control to stop all streams
                bool stopped = _canService?.StopAllStreams() ?? false;  // Stop all streams

                if (stopped)
                {
                    OnCANMessageReceived(new CANMessage(0x044, new byte[0]));
                }

                if (stopped)
                {
                    // Success state - Green
                    StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(40, 167, 69));
                    StopAllBtn.Content = "Stopped ✓";

                    // Reset to default after 2 seconds
                    Task.Delay(2000).ContinueWith(_ =>
                    {
                        Dispatcher.Invoke(() => {
                            StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(108, 117, 125));
                            StopAllBtn.Content = "Stop All";
                        });
                    });
                }
                else
                {
                    // Error state - Red
                    StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(220, 53, 69));
                    StopAllBtn.Content = "Failed ✗";

                    // Reset after 2 seconds
                    Task.Delay(2000).ContinueWith(_ =>
                    {
                        Dispatcher.Invoke(() => {
                            StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(108, 117, 125));
                            StopAllBtn.Content = "Stop All";
                        });
                    });
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Stop All Error: {ex.Message}");
            }
        }

        private void OpenCalibrationBtn_Click(object sender, RoutedEventArgs e)
        {
            // Open new v0.7 calibration dialog
            var calibrationDialog = new CalibrationDialog("Left");
            calibrationDialog.Owner = this;
            if (calibrationDialog.ShowDialog() == true)
            {
                // Reload calibrations after successful calibration
                LoadCalibrations();
                UpdateWeightDisplays();
            }
        }

        // OpenCalibrationWindow method bhi isi class me hona chahiye:
        private void OpenCalibrationWindow()
        {
            var calibDialog = new CalibrationDialog("Left");
            calibDialog.ShowDialog();
        }

        // Calibration verification is now handled by CalibrationDialog

        private void InitializeApplication()
        {
            if (MessageGrid != null)
                MessageGrid.ItemsSource = FilteredMessages;

            LoadConfiguration();
            
            // Load existing calibrations and tare settings
            LoadCalibrations();
            _tareManager.LoadFromFile();

            try
            {
                _canService = new CANService();  // Use new CANService
                _canService.MessageReceived += OnCANMessageReceived;
                _canService.RawDataReceived += OnRawDataReceived;
                System.Diagnostics.Debug.WriteLine("CAN Service initialized successfully");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"CAN Service initialization error: {ex.Message}");
                MessageBox.Show($"CAN Service initialization failed: {ex.Message}",
                               "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Warning);
            }

            _uiUpdateTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(100) };
            _uiUpdateTimer.Tick += (s, e) =>
            {
                try
                {
                    UpdateUI();
                    ProcessPendingMessages();
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"UI Update error: {ex.Message}");
                }
            };
            _uiUpdateTimer.Start();

            _clockTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(1) };
            _clockTimer.Tick += (s, e) => UpdateClock();
            _clockTimer.Start();

            UpdateConnectionStatus(false);
            System.Diagnostics.Debug.WriteLine("Suspension Application initialized - Protocol v0.5");
        }

        private void OnRawDataReceived(object? sender, RawDataEventArgs e)
        {
            try
            {
                lock (_dataLock)
                {
                    if (e.Side == 0) // Left side
                    {
                        _leftRawADC = e.RawADCSum;
                    }
                    else if (e.Side == 1) // Right side
                    {
                        _rightRawADC = e.RawADCSum;
                    }
                }
                
                System.Diagnostics.Debug.WriteLine($"Raw data received: Side={e.Side}, Raw={e.RawADCSum}");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Raw data received error: {ex.Message}");
            }
        }

        private void OnCANMessageReceived(CANMessage message)
        {
            try
            {
                if (message == null) return;

                System.Diagnostics.Debug.WriteLine($"Processing CAN message: ID=0x{message.ID:X3}, Data={BitConverter.ToString(message.Data)}");

                // Handle emergency commands
                if (message.ID == 0x000 || message.ID == 0x001)
                {
                    HandleEmergencyCommand(message);
                    return;
                }

                var vm = new CANMessageViewModel(message, _rxMessageIds, _txMessageIds);
                _messageQueue.Enqueue(vm);

                lock (_statisticsLock)
                {
                    _totalMessages++;
                    if (vm.Direction == "RX") _rxMessages++;
                    else if (vm.Direction == "TX") _txMessages++;
                }

                // Process weight and calibration data according to protocol v0.5
                lock (_dataLock)
                {
                    ProcessProtocolMessage(message);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"CAN message received error: {ex.Message}");
            }
        }

        private void ProcessProtocolMessage(CANMessage message)
        {
            switch (message.ID)
            {
                case 0x200: // Suspension Weight Data Response
                    if (message.Data?.Length >= 8)
                    {
                        _suspensionWeights.FrontLeft = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        _suspensionWeights.FrontRight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _suspensionWeights.RearLeft = BitConverter.ToUInt16(message.Data, 4) / 10.0;
                        _suspensionWeights.RearRight = BitConverter.ToUInt16(message.Data, 6) / 10.0;

                        System.Diagnostics.Debug.WriteLine($"Suspension Weights - FL:{_suspensionWeights.FrontLeft:F1} FR:{_suspensionWeights.FrontRight:F1} RL:{_suspensionWeights.RearLeft:F1} RR:{_suspensionWeights.RearRight:F1} kg");
                    }
                    break;

                case 0x201: // Axle Weight Data Response
                    if (message.Data?.Length >= 8)
                    {
                        _axleWeights.FrontLeft = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        _axleWeights.FrontRight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _axleWeights.RearLeft = BitConverter.ToUInt16(message.Data, 4) / 10.0;
                        _axleWeights.RearRight = BitConverter.ToUInt16(message.Data, 6) / 10.0;

                        System.Diagnostics.Debug.WriteLine($"Axle Weights - FL:{_axleWeights.FrontLeft:F1} FR:{_axleWeights.FrontRight:F1} RL:{_axleWeights.RearLeft:F1} RR:{_axleWeights.RearRight:F1} kg");
                    }
                    break;

                case 0x400: // Variable Calibration Data Response - NEW PROTOCOL FLOW
                    if (message.Data?.Length >= 8)
                    {
                        var pointData = new CalibrationPointData
                        {
                            PointIndex = message.Data[0],
                            PointStatus = message.Data[1],
                            ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0,
                            ADCValue = BitConverter.ToUInt16(message.Data, 4),
                            Timestamp = DateTime.Now
                        };

                        // Check if this is auto-generated point response (after 0x020)
                        if (_expectedCalibrationPoints > 0 && _receivedAutoGeneratedPoints < _expectedCalibrationPoints)
                        {
                            _autoGeneratedPoints.Add(pointData);
                            _receivedAutoGeneratedPoints++;

                            System.Diagnostics.Debug.WriteLine($"Auto-generated point received: Index={pointData.PointIndex}, Weight={pointData.ReferenceWeight:F1}kg ({_receivedAutoGeneratedPoints}/{_expectedCalibrationPoints})");

                            // When all auto-generated points received, log completion
                            if (_receivedAutoGeneratedPoints >= _expectedCalibrationPoints)
                            {
                                System.Diagnostics.Debug.WriteLine($"All {_expectedCalibrationPoints} calibration points received. Use new calibration dialog.");
                            }
                        }
                        else
                        {
                            // This is confirmation response after 0x022 (Set Weight Point)
                            System.Diagnostics.Debug.WriteLine($"Calibration point confirmed: Index={pointData.PointIndex}, Weight={pointData.ReferenceWeight:F1}kg, ADC={pointData.ADCValue}");
                        }

                        // Update legacy calibration data for UI display
                        _calibrationData.PointIndex = message.Data[0];
                        _calibrationData.PointStatus = message.Data[1];
                        _calibrationData.ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _calibrationData.ADCValue = BitConverter.ToUInt16(message.Data, 4);
                    }
                    break;

                case 0x401: // Calibration Quality Analysis Response (after 0x024)
                    if (message.Data?.Length >= 8)
                    {
                        var accuracyScore = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        var maxError = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        var qualityGrade = message.Data[4];
                        var recommendation = message.Data[5];

                        string gradeText = qualityGrade switch
                        {
                            0x01 => "Excellent",
                            0x02 => "Good",
                            0x03 => "Acceptable",
                            0x04 => "Poor",
                            0x05 => "Failed",
                            _ => "Unknown"
                        };

                        string recommendationText = recommendation switch
                        {
                            0x01 => "Accept Calibration",
                            0x02 => "Retry Calibration",
                            0x03 => "Add More Points",
                            _ => "No Recommendation"
                        };

                        Dispatcher.BeginInvoke(new Action(() => {
                            MessageBox.Show($"Calibration Analysis Complete!\n\n" +
                                          $"Accuracy Score: {accuracyScore:F1}%\n" +
                                          $"Max Error: {maxError:F1}kg\n" +
                                          $"Quality Grade: {gradeText}\n" +
                                          $"Recommendation: {recommendationText}",
                                          "Calibration Complete", MessageBoxButton.OK,
                                          qualityGrade <= 3 ? MessageBoxImage.Information : MessageBoxImage.Warning);

                            // Reset calibration state
                            ResetCalibrationState();
                        }));

                        // Update calibration data
                        _calibrationData.AccuracyScore = accuracyScore;
                        _calibrationData.MaxError = maxError;
                        _calibrationData.QualityGrade = qualityGrade;
                        _calibrationData.Recommendation = recommendation;

                        System.Diagnostics.Debug.WriteLine($"Calibration Analysis: {accuracyScore:F1}% accuracy, Grade: {gradeText}");
                    }
                    break;

                case 0x402: // Error Response System
                    if (message.Data?.Length >= 8)
                    {
                        uint errorCode = BitConverter.ToUInt16(message.Data, 0);
                        byte severity = message.Data[2];

                        string severityText = severity switch
                        {
                            0x01 => "INFO",
                            0x02 => "WARNING",
                            0x03 => "ERROR",
                            0x04 => "CRITICAL",
                            0x05 => "FATAL",
                            _ => "UNKNOWN"
                        };

                        System.Diagnostics.Debug.WriteLine($"System Error: Code=0x{errorCode:X4}, Severity={severityText}");

                        if (severity >= 0x04)
                        {
                            Dispatcher.BeginInvoke(new Action(() =>
                            {
                                MessageBox.Show($"Critical System Error!\n\nError Code: 0x{errorCode:X4}\nSeverity: {severityText}\n\nCheck system status immediately.",
                                              "Critical Error", MessageBoxButton.OK, MessageBoxImage.Error);
                            }));
                        }
                    }
                    break;
                    
                case 0x405: // Calibration Debug Response (for debugging)
                    if (message.Data?.Length >= 8)
                    {
                        var debugData = new CalibrationPointData
                        {
                            PointIndex = message.Data[0],
                            PointStatus = message.Data[1],
                            ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0,
                            ADCValue = BitConverter.ToUInt16(message.Data, 4),
                            Timestamp = DateTime.Now
                        };
                        
                        System.Diagnostics.Debug.WriteLine($"*** DEBUG RESPONSE (0x405): Point={debugData.PointIndex}, Status=0x{debugData.PointStatus:X2}, RefWeight={debugData.ReferenceWeight:F1}kg, ADC={debugData.ADCValue}, CurrentWeight={BitConverter.ToUInt16(message.Data, 6) / 10.0:F1}kg ***");
                    }
                    break;

                case 0x500: // System Status Summary
                    if (message.Data?.Length >= 3)
                    {
                        byte systemStatus = message.Data[0];
                        byte errorFlags = message.Data[1];
                        byte nodeCount = message.Data[2];

                        System.Diagnostics.Debug.WriteLine($"System Status: {systemStatus}, Error Flags: 0x{errorFlags:X2}, Nodes: {nodeCount}");
                    }
                    break;
            }
        }



        private void ResetCalibrationState()
        {
            _expectedCalibrationPoints = 0;
            _receivedAutoGeneratedPoints = 0;
            _autoGeneratedPoints.Clear();
        }

        private void HandleEmergencyCommand(CANMessage message)
        {
            try
            {
                string emergencyType = message.ID == 0x000 ? "Emergency Stop" : "System Shutdown";
                System.Diagnostics.Debug.WriteLine($"Emergency Command Received: {emergencyType}");

                var vm = new CANMessageViewModel(message, _rxMessageIds, _txMessageIds);
                _messageQueue.Enqueue(vm);

                // Show emergency notification
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    MessageBox.Show($"EMERGENCY COMMAND RECEIVED!\n\n{emergencyType}\nID: 0x{message.ID:X3}\nData: {BitConverter.ToString(message.Data)}\n\nSystem may enter safe mode.",
                                  "EMERGENCY ALERT", MessageBoxButton.OK, MessageBoxImage.Error);
                }));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Emergency command handling error: {ex.Message}");
            }
        }

        private void ProcessPendingMessages()
        {
            int processed = 0;
            while (_messageQueue.TryDequeue(out var vm) && processed < 10)
            {
                Messages.Add(vm);
                processed++;
                if (Messages.Count > 1000) Messages.RemoveAt(0);
            }

            if (processed > 0) ApplyMessageFilter();
        }

        private void ApplyMessageFilter()
        {
            try
            {
                FilteredMessages.Clear();
                var filtered = Messages.AsEnumerable();

                if (FilterIdTxt != null && !string.IsNullOrWhiteSpace(FilterIdTxt.Text) &&
                    uint.TryParse(FilterIdTxt.Text, System.Globalization.NumberStyles.HexNumber, null, out uint filterId))
                {
                    filtered = filtered.Where(m => m.Message.ID == filterId);
                }

                CheckBox? showTxChk = FindName("ShowTxChk") as CheckBox;
                CheckBox? showRxChk = FindName("ShowRxChk") as CheckBox;

                if (showTxChk?.IsChecked == true && showRxChk?.IsChecked != true)
                    filtered = filtered.Where(m => m.Direction == "TX");
                else if (showRxChk?.IsChecked == true && showTxChk?.IsChecked != true)
                    filtered = filtered.Where(m => m.Direction == "RX");

                foreach (var msg in filtered.TakeLast(200))
                    FilteredMessages.Add(msg);

                if (MessageCountTxt != null)
                    MessageCountTxt.Text = FilteredMessages.Count.ToString();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter application error: {ex.Message}");
            }
        }

        private void UpdateUI()
        {
            try
            {
                // Update weight displays if UI elements exist
                UpdateWeightDisplays();
                UpdateStatistics();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"UI update error: {ex.Message}");
            }
        }

        private void UpdateWeightDisplays()
        {
            lock (_dataLock)
            {
                try
                {
                    // Update Left Side Display
                    if (LeftRawTxt != null) LeftRawTxt.Text = _leftRawADC.ToString();
                    
                    double leftCalibratedKg = 0.0;
                    double leftCalSlope = 0.0;
                    double leftCalIntercept = 0.0;
                    if (_leftCalibration != null && _leftCalibration.IsValid)
                    {
                        leftCalibratedKg = _leftCalibration.RawToKg(_leftRawADC);
                        leftCalSlope = _leftCalibration.Slope;
                        leftCalIntercept = _leftCalibration.Intercept;
                        if (LeftCalibratedTxt != null) LeftCalibratedTxt.Text = $"{leftCalibratedKg:F1} kg";
                    }
                    else
                    {
                        if (LeftCalibratedTxt != null) LeftCalibratedTxt.Text = "Calibration Required";
                    }
                    
                    double leftDisplayKg = _tareManager.ApplyTare(leftCalibratedKg, true);
                    if (LeftDisplayTxt != null) LeftDisplayTxt.Text = $"{leftDisplayKg:F1} kg";
                    
                    if (LeftTareStatusTxt != null) LeftTareStatusTxt.Text = _tareManager.GetTareStatusText(true);
                    
                    // Log left side data
                    if (_dataLogger.IsLogging)
                    {
                        double leftTareBaseline = _tareManager.LeftIsTared ? _tareManager.LeftBaselineKg : 0.0;
                        _dataLogger.LogDataPoint("Left", _leftRawADC, leftCalibratedKg, leftDisplayKg, 
                                               leftTareBaseline, leftCalSlope, leftCalIntercept, 0);
                    }
                    
                    // Update Right Side Display
                    if (RightRawTxt != null) RightRawTxt.Text = _rightRawADC.ToString();
                    
                    double rightCalibratedKg = 0.0;
                    double rightCalSlope = 0.0;
                    double rightCalIntercept = 0.0;
                    if (_rightCalibration != null && _rightCalibration.IsValid)
                    {
                        rightCalibratedKg = _rightCalibration.RawToKg(_rightRawADC);
                        rightCalSlope = _rightCalibration.Slope;
                        rightCalIntercept = _rightCalibration.Intercept;
                        if (RightCalibratedTxt != null) RightCalibratedTxt.Text = $"{rightCalibratedKg:F1} kg";
                    }
                    else
                    {
                        if (RightCalibratedTxt != null) RightCalibratedTxt.Text = "Calibration Required";
                    }
                    
                    double rightDisplayKg = _tareManager.ApplyTare(rightCalibratedKg, false);
                    if (RightDisplayTxt != null) RightDisplayTxt.Text = $"{rightDisplayKg:F1} kg";
                    
                    if (RightTareStatusTxt != null) RightTareStatusTxt.Text = _tareManager.GetTareStatusText(false);
                    
                    // Log right side data
                    if (_dataLogger.IsLogging)
                    {
                        double rightTareBaseline = _tareManager.RightIsTared ? _tareManager.RightBaselineKg : 0.0;
                        _dataLogger.LogDataPoint("Right", _rightRawADC, rightCalibratedKg, rightDisplayKg, 
                                               rightTareBaseline, rightCalSlope, rightCalIntercept, 0);
                    }
                    
                    // Update Total and Balance
                    double totalWeight = leftDisplayKg + rightDisplayKg;
                    if (TotalWeightTxt != null) TotalWeightTxt.Text = $"{totalWeight:F1} kg";
                    
                    if (totalWeight > 0)
                    {
                        double leftPercent = (leftDisplayKg / totalWeight) * 100.0;
                        double rightPercent = (rightDisplayKg / totalWeight) * 100.0;
                        if (BalanceTxt != null) BalanceTxt.Text = $"{leftPercent:F0}% L / {rightPercent:F0}% R";
                    }
                    else
                    {
                        if (BalanceTxt != null) BalanceTxt.Text = "50% L / 50% R";
                    }

                    // Update System Status
                    if (DataRateTxt != null) DataRateTxt.Text = "Data Rate: 1kHz";
                    if (LastUpdateTxt != null) LastUpdateTxt.Text = $"Last Update: {DateTime.Now:HH:mm:ss}";
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"Weight display update error: {ex.Message}");
                }
            }
        }

        private void UpdateStatistics()
        {
            lock (_statisticsLock)
            {
                // Update message statistics if UI elements exist
                // TotalMessagesTxt?.Text = _totalMessages.ToString();
                // TxMessagesTxt?.Text = _txMessages.ToString();
                // RxMessagesTxt?.Text = _rxMessages.ToString();
            }
        }

        private void UpdateClock()
        {
            try
            {
                if (TimestampText != null)
                    TimestampText.Text = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Clock update error: {ex.Message}");
            }
        }

        private void UpdateConnectionStatus(bool connected)
        {
            try
            {
                if (StatusIndicator != null && StatusText != null && StatusBarText != null)
                {
                    if (connected)
                    {
                        StatusIndicator.Fill = new SolidColorBrush(Color.FromRgb(40, 167, 69));
                        StatusText.Text = "Connected";
                        StatusBarText.Text = $"Connected - USB-CAN - {GetSelectedBaudRate()} - Suspension Protocol v0.5";
                    }
                    else
                    {
                        StatusIndicator.Fill = new SolidColorBrush(Color.FromRgb(220, 53, 69));
                        StatusText.Text = "Disconnected";
                        StatusBarText.Text = "Disconnected - Check USB-CAN Connection";
                    }
                }

                if (ConnectBtn != null) ConnectBtn.IsEnabled = !connected;
                if (DisconnectBtn != null) DisconnectBtn.IsEnabled = connected;
                if (RequestSuspensionBtn != null) RequestSuspensionBtn.IsEnabled = connected;
                if (RequestAxleBtn != null) RequestAxleBtn.IsEnabled = connected;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Connection status update error: {ex.Message}");
            }
        }

        private string GetSelectedBaudRate()
        {
            try
            {
                return (BaudRateCombo?.SelectedItem as ComboBoxItem)?.Content?.ToString() ?? "250 kbps";
            }
            catch
            {
                return "250 kbps";
            }
        }

        private ushort GetBaudRateValue()
        {
            return GetSelectedBaudRate() switch
            {
                "1 Mbps" => 1000,
                "500 kbps" => 500,
                "250 kbps" => 250,
                "125 kbps" => 125,
                _ => 250
            };
        }

        private void ConnectBtn_Click(object sender, RoutedEventArgs e)
        {
            StopAllBtn.IsEnabled = true;  // stop 
            try
            {
                if (_canService == null)
                {
                    MessageBox.Show("CAN Service not initialized.", "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                bool connected = _canService.Connect(0, GetBaudRateValue());
                if (connected)
                {
                    UpdateConnectionStatus(true);
                    ResetStatistics();
                    MessageBox.Show("USB-CAN Connected Successfully.\n\nProtocol: CAN v0.5\nExpected responses:\n• 0x200 (Suspension weights)\n• 0x201 (Axle weights)\n• 0x400/0x401 (Calibration)\n• 0x402 (Errors)",
                                  "Connected", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else
                {
                    MessageBox.Show("Connection Failed. Check USB-CAN device.", "Connection Failed", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Connection Error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ResetStatistics()
        {
            lock (_statisticsLock)
            {
                _totalMessages = _txMessages = _rxMessages = 0;
            }

            lock (_dataLock)
            {
                _suspensionWeights = new SuspensionWeightData();
                _axleWeights = new AxleWeightData();
                _calibrationData = new CalibrationData();
            }
        }

        private void DisconnectBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _autoRequestTimer?.Stop();
                _canService?.Disconnect();
                UpdateConnectionStatus(false);
                StopAllBtn.IsEnabled = false;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Disconnect error: {ex.Message}");
            }
        }

        private void RequestSuspensionBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_canService?.IsConnected == true)
                {
                    // Check if left side calibration is valid before starting stream
                    if (_leftCalibration == null || !_leftCalibration.IsValid)
                    {
                        MessageBox.Show("Left side calibration is required before starting stream.\nPlease calibrate the left side first.", 
                                       "Calibration Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                    
                    // Start streaming left side at current rate using semantic ID
                    bool success = _canService.StartLeftStream(_currentTransmissionRate);
                    if (success)
                    {
                        OnCANMessageReceived(new CANMessage(0x040, new byte[] { _currentTransmissionRate }));
                    }
                }
                else
                {
                    MessageBox.Show("CAN service not connected.", "Connection Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Send Error: {ex.Message}", "CAN Transmission Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void RequestAxleBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_canService?.IsConnected == true)
                {
                    // Check if right side calibration is valid before starting stream
                    if (_rightCalibration == null || !_rightCalibration.IsValid)
                    {
                        MessageBox.Show("Right side calibration is required before starting stream.\nPlease calibrate the right side first.", 
                                       "Calibration Required", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                    
                    // Start streaming right side at current rate using semantic ID
                    bool success = _canService.StartRightStream(_currentTransmissionRate);
                    if (success)
                    {
                        OnCANMessageReceived(new CANMessage(0x041, new byte[] { _currentTransmissionRate }));
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Send Error: {ex.Message}", "CAN Transmission Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void TestSuspensionData()
        {
            try
            {
                var random = new Random();

                // Generate test suspension weight data (0x200 format)
                byte[] testData = new byte[8];
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 0); // FL
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 2); // FR
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 4); // RL
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 6); // RR

                OnCANMessageReceived(new CANMessage(0x200, testData));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Test suspension data error: {ex.Message}");
            }
        }

        // Old calibration system removed - now using CalibrationDialog

        private void AutoRequestChk_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (IntervalTxt != null && int.TryParse(IntervalTxt.Text, out int interval) && interval > 0)
                {
                    _autoRequestTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(interval) };
                    _autoRequestTimer.Tick += (s, args) =>
                    {
                        if (_autoRequestTimer?.Tag == null)
                        {
                            RequestSuspensionBtn_Click(this, new RoutedEventArgs());
                            _autoRequestTimer!.Tag = "axle";
                        }
                        else
                        {
                            RequestAxleBtn_Click(this, new RoutedEventArgs());
                            _autoRequestTimer!.Tag = null;
                        }
                    };
                    _autoRequestTimer.Start();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Auto request timer error: {ex.Message}");
            }
        }

        private void AutoRequestChk_Unchecked(object sender, RoutedEventArgs e)
        {
            try
            {
                _autoRequestTimer?.Stop();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Auto request stop error: {ex.Message}");
            }
        }

        private void ClearLogBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Messages.Clear();
                FilteredMessages.Clear();
                while (_messageQueue.TryDequeue(out _)) { }
                ResetStatistics();
                if (MessageCountTxt != null) MessageCountTxt.Text = "0";
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Clear log error: {ex.Message}");
            }
        }

        private void FilterIdTxt_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                ApplyMessageFilter();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter text change error: {ex.Message}");
            }
        }

        private void FilterChanged(object sender, RoutedEventArgs e)
        {
            try
            {
                ApplyMessageFilter();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter change error: {ex.Message}");
            }
        }

        private void LoadConfiguration()
        {
            try
            {
                string configPath = System.IO.Path.Combine(Environment.CurrentDirectory, "Suspension_Config.json");
                if (File.Exists(configPath))
                {
                    string jsonString = File.ReadAllText(configPath);
                    var config = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);
                    if (config != null && config.ContainsKey("AutoRequestInterval") && IntervalTxt != null)
                    {
                        IntervalTxt.Text = config["AutoRequestInterval"].ToString();
                    }
                    if (config != null && config.ContainsKey("TransmissionRate"))
                    {
                        _currentTransmissionRate = byte.Parse(config["TransmissionRate"].ToString() ?? "2");
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Could not load configuration: {ex.Message}");
            }
        }

        // v0.7 Calibration and Tare Methods
        private void LoadCalibrations()
        {
            _leftCalibration = LinearCalibration.LoadFromFile("Left");
            _rightCalibration = LinearCalibration.LoadFromFile("Right");
        }
        
        private void TareLeft_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_leftCalibration == null || !_leftCalibration.IsValid)
                {
                    MessageBox.Show("Please calibrate the Left side first before taring.", "Calibration Required", 
                                  MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                
                double currentCalibratedKg = _leftCalibration.RawToKg(_leftRawADC);
                _tareManager.TareLeft(currentCalibratedKg);
                _tareManager.SaveToFile();
                
                UpdateWeightDisplays();
                MessageBox.Show($"Left side tared successfully.\nBaseline: {currentCalibratedKg:F1} kg", 
                              "Tare Complete", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error taring Left side: {ex.Message}", "Tare Error", 
                              MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        
        private void TareRight_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_rightCalibration == null || !_rightCalibration.IsValid)
                {
                    MessageBox.Show("Please calibrate the Right side first before taring.", "Calibration Required", 
                                  MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }
                
                double currentCalibratedKg = _rightCalibration.RawToKg(_rightRawADC);
                _tareManager.TareRight(currentCalibratedKg);
                _tareManager.SaveToFile();
                
                UpdateWeightDisplays();
                MessageBox.Show($"Right side tared successfully.\nBaseline: {currentCalibratedKg:F1} kg", 
                              "Tare Complete", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error taring Right side: {ex.Message}", "Tare Error", 
                              MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        
        private void ResetTares_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _tareManager.ResetBoth();
                _tareManager.SaveToFile();
                UpdateWeightDisplays();
                MessageBox.Show("All tares reset successfully.", "Reset Complete", 
                              MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error resetting tares: {ex.Message}", "Reset Error", 
                              MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        
        private void CalibrateLeft_Click(object sender, RoutedEventArgs e)
        {
            var calibrationDialog = new CalibrationDialog("Left");
            calibrationDialog.Owner = this;
            if (calibrationDialog.ShowDialog() == true)
            {
                LoadCalibrations();
                UpdateWeightDisplays();
            }
        }
        
        private void CalibrateRight_Click(object sender, RoutedEventArgs e)
        {
            var calibrationDialog = new CalibrationDialog("Right");
            calibrationDialog.Owner = this;
            if (calibrationDialog.ShowDialog() == true)
            {
                LoadCalibrations();
                UpdateWeightDisplays();
            }
        }
        
        private void StartLogging_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_dataLogger.StartLogging())
                {
                    StartLoggingBtn.IsEnabled = false;
                    StopLoggingBtn.IsEnabled = true;
                    LoggingStatusTxt.Text = $"Logging to: {_dataLogger.GetLogFilePath()}";
                    LoggingStatusTxt.Foreground = System.Windows.Media.Brushes.Green;
                }
                else
                {
                    MessageBox.Show("Failed to start data logging.", "Logging Error", 
                                  MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error starting logging: {ex.Message}", "Logging Error", 
                              MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        
        private void StopLogging_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _dataLogger.StopLogging();
                StartLoggingBtn.IsEnabled = true;
                StopLoggingBtn.IsEnabled = false;
                LoggingStatusTxt.Text = $"Stopped. Logged {_dataLogger.GetLogLineCount()} lines.";
                LoggingStatusTxt.Foreground = System.Windows.Media.Brushes.Orange;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error stopping logging: {ex.Message}", "Logging Error", 
                              MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        
        private void ExportLog_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var saveDialog = new Microsoft.Win32.SaveFileDialog
                {
                    Filter = "CSV files (*.csv)|*.csv|All files (*.*)|*.*",
                    DefaultExt = "csv",
                    FileName = $"suspension_export_{DateTime.Now:yyyyMMdd_HHmmss}.csv"
                };
                
                if (saveDialog.ShowDialog() == true)
                {
                    if (_dataLogger.ExportToCSV(saveDialog.FileName))
                    {
                        MessageBox.Show($"Data exported successfully to:\n{saveDialog.FileName}", 
                                      "Export Complete", MessageBoxButton.OK, MessageBoxImage.Information);
                    }
                    else
                    {
                        MessageBox.Show("Failed to export data. No log file found.", "Export Error", 
                                      MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error exporting data: {ex.Message}", "Export Error", 
                              MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        protected override void OnClosing(CancelEventArgs e)
        {
            try
            {
                // Stop all timers
                _uiUpdateTimer?.Stop();
                _autoRequestTimer?.Stop();
                _clockTimer?.Stop();

                // Stop data transmission if active
                if (_canService?.IsConnected == true)
                {
                // Stop all streams using v0.7 semantic stream control
                _canService.StopAllStreams();  // Stop all streams
                }

                // Disconnect CAN service
                _canService?.Disconnect();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Window closing error: {ex.Message}");
            }
            finally
            {
                base.OnClosing(e);
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // CalibrationPointData class for protocol flow
    public class CalibrationPointData
    {
        public byte PointIndex { get; set; }
        public byte PointStatus { get; set; }
        public double ReferenceWeight { get; set; }
        public int ADCValue { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.Now;
    }

    // Data structures for protocol v0.5
    public class SuspensionWeightData
    {
        public double FrontLeft { get; set; } = 0.0;
        public double FrontRight { get; set; } = 0.0;
        public double RearLeft { get; set; } = 0.0;
        public double RearRight { get; set; } = 0.0;

        public double TotalWeight => FrontLeft + FrontRight + RearLeft + RearRight;
        public double FrontAxle => FrontLeft + FrontRight;
        public double RearAxle => RearLeft + RearRight;
    }

    public class AxleWeightData
    {
        public double FrontLeft { get; set; } = 0.0;
        public double FrontRight { get; set; } = 0.0;
        public double RearLeft { get; set; } = 0.0;
        public double RearRight { get; set; } = 0.0;

        public double TotalWeight => FrontLeft + FrontRight + RearLeft + RearRight;
        public double FrontAxle => FrontLeft + FrontRight;
        public double RearAxle => RearLeft + RearRight;
    }

    public class CalibrationData
    {
        public byte PointIndex { get; set; } = 0;
        public byte PointStatus { get; set; } = 0;
        public double ReferenceWeight { get; set; } = 0.0;
        public int ADCValue { get; set; } = 0;
        public double AccuracyScore { get; set; } = 0.0;
        public double MaxError { get; set; } = 0.0;
        public byte QualityGrade { get; set; } = 0;
        public byte Recommendation { get; set; } = 0;

        public string GetStatusText()
        {
            return PointStatus switch
            {
                0x00 => "Valid",
                0x01 => "ADC Timeout",
                0x02 => "Hardware Failure",
                0x03 => "Weight Exceeds Maximum",
                0x04 => "ADC Out of Range",
                0x05 => "Unstable Reading",
                0x06 => "Invalid Point Index",
                0x07 => "Calibration Not Active",
                0x80 => "Calibration Started",
                0x81 => "Session Reset",
                0x82 => "Calibration Completed",
                0x83 => "Calibration Saved",
                0x84 => "Calibration Loaded",
                0x85 => "Point Deleted",
                0x86 => "Session Reset",
                0x87 => "Point Count",
                0x88 => "Specific Point Deleted",
                0x90 => "Calibrated Weight Verification", // After calibration complete
                0x91 => "Raw ADC Conversion (During Calibration)", // During calibration
                0x92 => "Current Weight at Start", // Average weight of selected channels
                _ => $"Unknown Error (0x{PointStatus:X2})"
            };
        }

        public string GetQualityText()
        {
            return QualityGrade switch
            {
                0x01 => "Excellent (90%+)",
                0x02 => "Good (80-89%)",
                0x03 => "Acceptable (70-79%)",
                0x04 => "Poor (60-69%)",
                0x05 => "Failed (<60%)",
                _ => "Unknown"
            };
        }

        public string GetRecommendationText()
        {
            return Recommendation switch
            {
                0x01 => "Accept Calibration",
                0x02 => "Retry Calibration",
                0x03 => "Add More Points",
                _ => "No Recommendation"
            };
        }
    }

}