using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Threading;
using System.Windows.Media;
using System.IO;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Windows.Input;
using System.Windows.Controls;
using System.Threading.Tasks;

namespace SuspensionPCB_CAN_WPF
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private DispatcherTimer? _uiUpdateTimer;
        private DispatcherTimer? _autoRequestTimer;
        private DispatcherTimer? _clockTimer;

        private DateTime _startTime;
        private volatile int _totalMessages, _txMessages, _rxMessages;
        private readonly object _dataLock = new object();
        private CANService? _canService;  // Changed from USBCANManager to CANService
        private readonly object _statisticsLock = new object();
        private volatile bool _isConnected = false;

        // Add calibration state fields
        private int _expectedCalibrationPoints = 0;
        private int _receivedAutoGeneratedPoints = 0;
        private List<CalibrationPointData> _autoGeneratedPoints = new List<CalibrationPointData>();
        private WeightCalibrationPoint? _activeCalibrationWindow = null;

        // Suspension system weight data (protocol v0.5 format)
        private SuspensionWeightData _suspensionWeights = new SuspensionWeightData();
        private AxleWeightData _axleWeights = new AxleWeightData();
        private CalibrationData _calibrationData = new CalibrationData();
        

        // Thread-safe collections for better performance
        private readonly ConcurrentQueue<CANMessageViewModel> _messageQueue = new ConcurrentQueue<CANMessageViewModel>();
        public ObservableCollection<CANMessageViewModel> Messages { get; set; } = new ObservableCollection<CANMessageViewModel>();
        public ObservableCollection<CANMessageViewModel> FilteredMessages { get; set; } = new ObservableCollection<CANMessageViewModel>();

        // Updated message IDs according to CAN Protocol Specification v0.6 - Suspension System Only
        private readonly HashSet<uint> _rxMessageIds = new HashSet<uint> {
            0x200,  // Suspension weight data response (calibrated/uncalibrated)
            0x201,  // Axle weight data response (calibrated/uncalibrated)
            0x400,  // Variable calibration data response
            0x401,  // Calibration quality analysis response
            0x402,  // Error response system
            0x500   // System status summary
        };

        private readonly HashSet<uint> _txMessageIds = new HashSet<uint> {
            0x000, 0x001,               // Emergency commands
            0x020, 0x022, 0x023, 0x024, // Variable multi-point calibration commands
            0x025, 0x026, 0x027,        // Flash storage and load cell commands
            0x030, 0x031                // Data request commands (suspension & axle only)
        };

        // Current transmission state
        private bool _suspensionTransmissionActive = false;
        private bool _axleTransmissionActive = false;
        private byte _currentTransmissionRate = 0x02; // Default 500Hz

        public MainWindow()
        {
            InitializeComponent();
            this.DataContext = this;
            InitializeApplication();
        }

        private void StopAll_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // Change to loading state
                StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(255, 193, 7)); // Yellow
                StopAllBtn.Content = "Stopping...";

                // Use dedicated stop methods
                bool suspensionStopped = _canService.StopSuspensionData();
                bool axleStopped = _canService.StopAxleData();

                if (suspensionStopped)
                {
                    OnCANMessageReceived(new CANMessage(0x030, new byte[8]));
                }
                if (axleStopped)
                {
                    OnCANMessageReceived(new CANMessage(0x031, new byte[8]));
                }

                if (suspensionStopped && axleStopped)
                {
                    // Success state - Green
                    StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(40, 167, 69));
                    StopAllBtn.Content = "Stopped ✓";

                    // Reset to default after 2 seconds
                    Task.Delay(2000).ContinueWith(_ =>
                    {
                        Dispatcher.Invoke(() => {
                            StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(108, 117, 125));
                            StopAllBtn.Content = "Stop All";
                        });
                    });
                }
                else
                {
                    // Error state - Red
                    StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(220, 53, 69));
                    StopAllBtn.Content = "Failed ✗";

                    // Reset after 2 seconds
                    Task.Delay(2000).ContinueWith(_ =>
                    {
                        Dispatcher.Invoke(() => {
                            StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(108, 117, 125));
                            StopAllBtn.Content = "Stop All";
                        });
                    });
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Stop All Error: {ex.Message}");
            }
        }

        private void OpenCalibrationBtn_Click(object sender, RoutedEventArgs e)
        {
            // Open single-page calibration window
            var singlePageCalib = new SinglePageCalibration();
            singlePageCalib.Owner = this;
            singlePageCalib.ShowDialog();
        }

        // OpenCalibrationWindow method bhi isi class me hona chahiye:
        private void OpenCalibrationWindow()
        {
            var calibWindow = new CalibrationWindow(this);  // ✅
            calibWindow.ShowDialog();

            calibWindow.Owner = this;      // optional
            calibWindow.ShowDialog();      // modal open
        }

        // Open Calibration Verification Window
        private void OpenCalibrationVerificationWindow()
        {
            try
            {
                var verificationWindow = new CalibrationVerificationWindow();
                verificationWindow.Owner = this;
                verificationWindow.ShowDialog();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error opening calibration verification window: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void InitializeApplication()
        {
            if (MessageGrid != null)
                MessageGrid.ItemsSource = FilteredMessages;

            LoadConfiguration();

            try
            {
                _canService = new CANService();  // Use new CANService
                _canService.MessageReceived += OnCANMessageReceived;
                System.Diagnostics.Debug.WriteLine("CAN Service initialized successfully");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"CAN Service initialization error: {ex.Message}");
                MessageBox.Show($"CAN Service initialization failed: {ex.Message}",
                               "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Warning);
            }

            _uiUpdateTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(100) };
            _uiUpdateTimer.Tick += (s, e) =>
            {
                try
                {
                    UpdateUI();
                    ProcessPendingMessages();
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"UI Update error: {ex.Message}");
                }
            };
            _uiUpdateTimer.Start();

            _clockTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(1) };
            _clockTimer.Tick += (s, e) => UpdateClock();
            _clockTimer.Start();

            UpdateConnectionStatus(false);
            System.Diagnostics.Debug.WriteLine("Suspension Application initialized - Protocol v0.5");
        }

        private void OnCANMessageReceived(CANMessage message)
        {
            try
            {
                if (message == null) return;

                System.Diagnostics.Debug.WriteLine($"Processing CAN message: ID=0x{message.ID:X3}, Data={BitConverter.ToString(message.Data)}");

                // Handle emergency commands
                if (message.ID == 0x000 || message.ID == 0x001)
                {
                    HandleEmergencyCommand(message);
                    return;
                }

                var vm = new CANMessageViewModel(message, _rxMessageIds, _txMessageIds);
                _messageQueue.Enqueue(vm);

                lock (_statisticsLock)
                {
                    _totalMessages++;
                    if (vm.Direction == "RX") _rxMessages++;
                    else if (vm.Direction == "TX") _txMessages++;
                }

                // Process weight and calibration data according to protocol v0.5
                lock (_dataLock)
                {
                    ProcessProtocolMessage(message);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"CAN message received error: {ex.Message}");
            }
        }

        private void ProcessProtocolMessage(CANMessage message)
        {
            switch (message.ID)
            {
                case 0x200: // Suspension Weight Data Response (Calibrated/Uncalibrated)
                    if (message.Data?.Length >= 8)
                    {
                        // Always update the main suspension weights display
                        _suspensionWeights.FrontLeft = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        _suspensionWeights.FrontRight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _suspensionWeights.RearLeft = BitConverter.ToUInt16(message.Data, 4) / 10.0;
                        _suspensionWeights.RearRight = BitConverter.ToUInt16(message.Data, 6) / 10.0;

                        // Check if this is calibrated or uncalibrated data based on current request
                        bool isUncalibrated = DataTypeCombo.SelectedIndex == 1;
                        string dataType = isUncalibrated ? "Uncalibrated" : "Calibrated";
                        
                        // Update display title to show current data type
                        if (SuspensionTitleTxt != null)
                        {
                            SuspensionTitleTxt.Text = $"Suspension Weights ({dataType}) (kg)";
                        }
                        
                        System.Diagnostics.Debug.WriteLine($"Suspension Weights ({dataType}) - FL:{_suspensionWeights.FrontLeft:F1} FR:{_suspensionWeights.FrontRight:F1} RL:{_suspensionWeights.RearLeft:F1} RR:{_suspensionWeights.RearRight:F1} kg");
                    }
                    break;

                case 0x201: // Axle Weight Data Response (Calibrated/Uncalibrated)
                    if (message.Data?.Length >= 8)
                    {
                        // Always update the main axle weights display
                        _axleWeights.FrontLeft = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        _axleWeights.FrontRight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _axleWeights.RearLeft = BitConverter.ToUInt16(message.Data, 4) / 10.0;
                        _axleWeights.RearRight = BitConverter.ToUInt16(message.Data, 6) / 10.0;

                        // Check if this is calibrated or uncalibrated data based on current request
                        bool isUncalibrated = DataTypeCombo.SelectedIndex == 1;
                        string dataType = isUncalibrated ? "Uncalibrated" : "Calibrated";
                        
                        // Update display title to show current data type
                        if (AxleTitleTxt != null)
                        {
                            AxleTitleTxt.Text = $"Axle Weights ({dataType}) (kg)";
                        }
                        
                        System.Diagnostics.Debug.WriteLine($"Axle Weights ({dataType}) - FL:{_axleWeights.FrontLeft:F1} FR:{_axleWeights.FrontRight:F1} RL:{_axleWeights.RearLeft:F1} RR:{_axleWeights.RearRight:F1} kg");
                    }
                    break;

                case 0x400: // Variable Calibration Data Response - NEW PROTOCOL FLOW
                    if (message.Data?.Length >= 8)
                    {
                        var pointData = new CalibrationPointData
                        {
                            PointIndex = message.Data[0],
                            PointStatus = message.Data[1],
                            ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0,
                            ADCValue = BitConverter.ToUInt16(message.Data, 4),
                            Timestamp = DateTime.Now
                        };

                        // Check if this is auto-generated point response (after 0x020)
                        if (_expectedCalibrationPoints > 0 && _receivedAutoGeneratedPoints < _expectedCalibrationPoints)
                        {
                            _autoGeneratedPoints.Add(pointData);
                            _receivedAutoGeneratedPoints++;

                            System.Diagnostics.Debug.WriteLine($"Auto-generated point received: Index={pointData.PointIndex}, Weight={pointData.ReferenceWeight:F1}kg ({_receivedAutoGeneratedPoints}/{_expectedCalibrationPoints})");

                            // When all auto-generated points received, open WeightCalibrationPoint
                            if (_receivedAutoGeneratedPoints >= _expectedCalibrationPoints)
                            {
                                Dispatcher.BeginInvoke(new Action(() => {
                                    OpenWeightCalibrationWindowWithAutoPoints();
                                }));
                            }
                        }
                        else if (_activeCalibrationWindow != null)
                        {
                            // This is confirmation response after 0x022 (Set Weight Point)
                            System.Diagnostics.Debug.WriteLine($"Calibration point confirmed: Index={pointData.PointIndex}, Weight={pointData.ReferenceWeight:F1}kg, ADC={pointData.ADCValue}");
                        }

                        // Update legacy calibration data for UI display
                        _calibrationData.PointIndex = message.Data[0];
                        _calibrationData.PointStatus = message.Data[1];
                        _calibrationData.ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _calibrationData.ADCValue = BitConverter.ToUInt16(message.Data, 4);
                    }
                    break;

                case 0x401: // Calibration Quality Analysis Response (after 0x024)
                    if (message.Data?.Length >= 8)
                    {
                        var accuracyScore = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        var maxError = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        var qualityGrade = message.Data[4];
                        var recommendation = message.Data[5];

                        string gradeText = qualityGrade switch
                        {
                            0x01 => "Excellent",
                            0x02 => "Good",
                            0x03 => "Acceptable",
                            0x04 => "Poor",
                            0x05 => "Failed",
                            _ => "Unknown"
                        };

                        string recommendationText = recommendation switch
                        {
                            0x01 => "Accept Calibration",
                            0x02 => "Retry Calibration",
                            0x03 => "Add More Points",
                            _ => "No Recommendation"
                        };

                        Dispatcher.BeginInvoke(new Action(() => {
                            MessageBox.Show($"Calibration Analysis Complete!\n\n" +
                                          $"Accuracy Score: {accuracyScore:F1}%\n" +
                                          $"Max Error: {maxError:F1}kg\n" +
                                          $"Quality Grade: {gradeText}\n" +
                                          $"Recommendation: {recommendationText}",
                                          "Calibration Complete", MessageBoxButton.OK,
                                          qualityGrade <= 3 ? MessageBoxImage.Information : MessageBoxImage.Warning);

                            // Reset calibration state
                            ResetCalibrationState();
                        }));

                        // Update calibration data
                        _calibrationData.AccuracyScore = accuracyScore;
                        _calibrationData.MaxError = maxError;
                        _calibrationData.QualityGrade = qualityGrade;
                        _calibrationData.Recommendation = recommendation;

                        System.Diagnostics.Debug.WriteLine($"Calibration Analysis: {accuracyScore:F1}% accuracy, Grade: {gradeText}");
                    }
                    break;

                case 0x402: // Error Response System
                    if (message.Data?.Length >= 8)
                    {
                        uint errorCode = BitConverter.ToUInt16(message.Data, 0);
                        byte severity = message.Data[2];

                        string severityText = severity switch
                        {
                            0x01 => "INFO",
                            0x02 => "WARNING",
                            0x03 => "ERROR",
                            0x04 => "CRITICAL",
                            0x05 => "FATAL",
                            _ => "UNKNOWN"
                        };

                        System.Diagnostics.Debug.WriteLine($"System Error: Code=0x{errorCode:X4}, Severity={severityText}");

                        if (severity >= 0x04)
                        {
                            Dispatcher.BeginInvoke(new Action(() =>
                            {
                                MessageBox.Show($"Critical System Error!\n\nError Code: 0x{errorCode:X4}\nSeverity: {severityText}\n\nCheck system status immediately.",
                                              "Critical Error", MessageBoxButton.OK, MessageBoxImage.Error);
                            }));
                        }
                    }
                    break;
                    
                case 0x405: // Calibration Debug Response (for debugging)
                    if (message.Data?.Length >= 8)
                    {
                        var debugData = new CalibrationPointData
                        {
                            PointIndex = message.Data[0],
                            PointStatus = message.Data[1],
                            ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0,
                            ADCValue = BitConverter.ToUInt16(message.Data, 4),
                            Timestamp = DateTime.Now
                        };
                        
                        System.Diagnostics.Debug.WriteLine($"*** DEBUG RESPONSE (0x405): Point={debugData.PointIndex}, Status=0x{debugData.PointStatus:X2}, RefWeight={debugData.ReferenceWeight:F1}kg, ADC={debugData.ADCValue}, CurrentWeight={BitConverter.ToUInt16(message.Data, 6) / 10.0:F1}kg ***");
                    }
                    break;

                case 0x500: // System Status Summary
                    if (message.Data?.Length >= 3)
                    {
                        byte systemStatus = message.Data[0];
                        byte errorFlags = message.Data[1];
                        byte nodeCount = message.Data[2];

                        System.Diagnostics.Debug.WriteLine($"System Status: {systemStatus}, Error Flags: 0x{errorFlags:X2}, Nodes: {nodeCount}");
                    }
                    break;
            }
        }

        private void OpenWeightCalibrationWindowImmediately(int totalPoints, double maxWeight, byte channelMask, byte polyOrder)
        {
            try
            {
                _activeCalibrationWindow = new WeightCalibrationPoint(
                    totalPoints,    // totalPoints
                    maxWeight,      // maxKg  
                    channelMask,    // channels
                    polyOrder       // polyOrder
                );

                _activeCalibrationWindow.Owner = this;
                _activeCalibrationWindow.Show();

                System.Diagnostics.Debug.WriteLine($"WeightCalibrationPoint opened immediately - waiting for 0x400 response with status 0x80");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error opening calibration window: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void OpenWeightCalibrationWindowWithAutoPoints()
        {
            try
            {
                if (_autoGeneratedPoints.Count > 0)
                {
                    var maxWeight = _autoGeneratedPoints.Max(p => p.ReferenceWeight);

                    _activeCalibrationWindow = new WeightCalibrationPoint(
                        _expectedCalibrationPoints,  // totalPoints
                        maxWeight,                   // maxKg  
                        0x0F,                       // channels (all 4)
                        2                           // polyOrder (default)
                    );

                    _activeCalibrationWindow.Owner = this;
                    _activeCalibrationWindow.Show();

                    System.Diagnostics.Debug.WriteLine($"WeightCalibrationPoint opened with {_autoGeneratedPoints.Count} auto-generated target weights");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error opening calibration window: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ResetCalibrationState()
        {
            _expectedCalibrationPoints = 0;
            _receivedAutoGeneratedPoints = 0;
            _autoGeneratedPoints.Clear();
            _activeCalibrationWindow = null;
        }

        private void HandleEmergencyCommand(CANMessage message)
        {
            try
            {
                string emergencyType = message.ID == 0x000 ? "Emergency Stop" : "System Shutdown";
                System.Diagnostics.Debug.WriteLine($"Emergency Command Received: {emergencyType}");

                var vm = new CANMessageViewModel(message, _rxMessageIds, _txMessageIds);
                _messageQueue.Enqueue(vm);

                // Show emergency notification
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    MessageBox.Show($"EMERGENCY COMMAND RECEIVED!\n\n{emergencyType}\nID: 0x{message.ID:X3}\nData: {BitConverter.ToString(message.Data)}\n\nSystem may enter safe mode.",
                                  "EMERGENCY ALERT", MessageBoxButton.OK, MessageBoxImage.Error);
                }));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Emergency command handling error: {ex.Message}");
            }
        }

        private void ProcessPendingMessages()
        {
            int processed = 0;
            while (_messageQueue.TryDequeue(out var vm) && processed < 10)
            {
                Messages.Add(vm);
                processed++;
                if (Messages.Count > 1000) Messages.RemoveAt(0);
            }

            if (processed > 0) ApplyMessageFilter();
        }

        private void ApplyMessageFilter()
        {
            try
            {
                FilteredMessages.Clear();
                var filtered = Messages.AsEnumerable();

                if (FilterIdTxt != null && !string.IsNullOrWhiteSpace(FilterIdTxt.Text) &&
                    uint.TryParse(FilterIdTxt.Text, System.Globalization.NumberStyles.HexNumber, null, out uint filterId))
                {
                    filtered = filtered.Where(m => m.Message.ID == filterId);
                }

                CheckBox? showTxChk = FindName("ShowTxChk") as CheckBox;
                CheckBox? showRxChk = FindName("ShowRxChk") as CheckBox;

                if (showTxChk?.IsChecked == true && showRxChk?.IsChecked != true)
                    filtered = filtered.Where(m => m.Direction == "TX");
                else if (showRxChk?.IsChecked == true && showTxChk?.IsChecked != true)
                    filtered = filtered.Where(m => m.Direction == "RX");

                foreach (var msg in filtered.TakeLast(200))
                    FilteredMessages.Add(msg);

                if (MessageCountTxt != null)
                    MessageCountTxt.Text = FilteredMessages.Count.ToString();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter application error: {ex.Message}");
            }
        }

        private void UpdateUI()
        {
            try
            {
                // Update weight displays if UI elements exist
                UpdateWeightDisplays();
                UpdateStatistics();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"UI update error: {ex.Message}");
            }
        }

        private void UpdateWeightDisplays()
        {
            lock (_dataLock)
            {
                try
                {
                    // Update Suspension Weight Display (Calibrated)
                    if (SuspensionFLTxt != null) SuspensionFLTxt.Text = _suspensionWeights.FrontLeft.ToString("F1");
                    if (SuspensionFRTxt != null) SuspensionFRTxt.Text = _suspensionWeights.FrontRight.ToString("F1");
                    if (SuspensionRLTxt != null) SuspensionRLTxt.Text = _suspensionWeights.RearLeft.ToString("F1");
                    if (SuspensionRRTxt != null) SuspensionRRTxt.Text = _suspensionWeights.RearRight.ToString("F1");
                    if (SuspensionTotalTxt != null) SuspensionTotalTxt.Text = _suspensionWeights.TotalWeight.ToString("F1");


                    // Update Axle Weight Display
                    if (AxleFLTxt != null) AxleFLTxt.Text = _axleWeights.FrontLeft.ToString("F1");
                    if (AxleFRTxt != null) AxleFRTxt.Text = _axleWeights.FrontRight.ToString("F1");
                    if (AxleRLTxt != null) AxleRLTxt.Text = _axleWeights.RearLeft.ToString("F1");
                    if (AxleRRTxt != null) AxleRRTxt.Text = _axleWeights.RearRight.ToString("F1");
                    if (AxleTotalTxt != null) AxleTotalTxt.Text = _axleWeights.TotalWeight.ToString("F1");

                    // Update System Status
                    if (DataRateTxt != null) DataRateTxt.Text = "Data Rate: 500Hz";
                    if (LastUpdateTxt != null) LastUpdateTxt.Text = $"Last Update: {DateTime.Now:HH:mm:ss}";
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"Weight display update error: {ex.Message}");
                }
            }
        }

        private void UpdateStatistics()
        {
            lock (_statisticsLock)
            {
                // Update message statistics if UI elements exist
                // TotalMessagesTxt?.Text = _totalMessages.ToString();
                // TxMessagesTxt?.Text = _txMessages.ToString();
                // RxMessagesTxt?.Text = _rxMessages.ToString();
            }
        }

        private void UpdateClock()
        {
            try
            {
                if (TimestampText != null)
                    TimestampText.Text = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Clock update error: {ex.Message}");
            }
        }

        private void UpdateConnectionStatus(bool connected)
        {
            try
            {
                if (StatusIndicator != null && StatusText != null && StatusBarText != null)
                {
                    if (connected)
                    {
                        StatusIndicator.Fill = new SolidColorBrush(Color.FromRgb(40, 167, 69));
                        StatusText.Text = "Connected";
                        StatusBarText.Text = $"Connected - USB-CAN - {GetSelectedBaudRate()} - Suspension Protocol v0.5";
                    }
                    else
                    {
                        StatusIndicator.Fill = new SolidColorBrush(Color.FromRgb(220, 53, 69));
                        StatusText.Text = "Disconnected";
                        StatusBarText.Text = "Disconnected - Check USB-CAN Connection";
                    }
                }

                if (ConnectBtn != null) ConnectBtn.IsEnabled = !connected;
                if (DisconnectBtn != null) DisconnectBtn.IsEnabled = connected;
                if (RequestSuspensionBtn != null) RequestSuspensionBtn.IsEnabled = connected;
                if (RequestAxleBtn != null) RequestAxleBtn.IsEnabled = connected;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Connection status update error: {ex.Message}");
            }
        }

        private string GetSelectedBaudRate()
        {
            // Fixed at 250 kbps - no longer user selectable
            return "250 kbps";
        }

        private ushort GetBaudRateValue()
        {
            return GetSelectedBaudRate() switch
            {
                "1 Mbps" => 1000,
                "500 kbps" => 500,
                "250 kbps" => 250,
                "125 kbps" => 125,
                _ => 250
            };
        }

        private void ConnectBtn_Click(object sender, RoutedEventArgs e)
        {
            StopAllBtn.IsEnabled = true;  // stop 
            try
            {
                if (_canService == null)
                {
                    MessageBox.Show("CAN Service not initialized.", "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                // Get selected transmission rate
                _currentTransmissionRate = (byte)(TransmissionRateCombo.SelectedIndex + 1); // 0x01-0x04

                bool connected = _canService.Connect(0, 250); // Fixed 250 kbps
                if (connected)
                {
                    UpdateConnectionStatus(true);
                    ResetStatistics();
                    _isConnected = true;
                    MessageBox.Show($"USB-CAN Connected Successfully.\n\nProtocol: CAN v0.6\nTransmission Rate: {GetTransmissionRateText()}\nExpected responses:\n• 0x200 (Suspension weights)\n• 0x201 (Axle weights)\n• 0x400/0x401 (Calibration)\n• 0x402 (Errors)",
                                  "Connected", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else
                {
                    MessageBox.Show("Connection Failed. Check USB-CAN device.", "Connection Failed", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Connection Error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private string GetTransmissionRateText()
        {
            return TransmissionRateCombo.SelectedIndex switch
            {
                0 => "100 Hz",
                1 => "500 Hz", 
                2 => "1024 Hz",
                3 => "2000 Hz",
                _ => "Unknown"
            };
        }

        private void ResetStatistics()
        {
            lock (_statisticsLock)
            {
                _totalMessages = _txMessages = _rxMessages = 0;
            }

            lock (_dataLock)
            {
                _suspensionWeights = new SuspensionWeightData();
                _axleWeights = new AxleWeightData();
                _calibrationData = new CalibrationData();
            }
        }

        private void DisconnectBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _autoRequestTimer?.Stop();
                _canService?.Disconnect();
                _isConnected = false;
                _suspensionTransmissionActive = false;
                _axleTransmissionActive = false;
                UpdateConnectionStatus(false);
                StopAllBtn.IsEnabled = false;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Disconnect error: {ex.Message}");
            }
        }

        private void RequestSuspensionBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_canService?.IsConnected == true)
                {
                    // Check dropdown selection for data type
                    bool isUncalibrated = DataTypeCombo.SelectedIndex == 1; // 0=Calibrated, 1=Uncalibrated
                    
                    bool success;
                    uint messageId;
                    byte[] data;
                    
                    if (isUncalibrated)
                    {
                        // Request uncalibrated weight data using data byte approach
                        success = _canService.RequestSuspensionData(true, _currentTransmissionRate, 0x02); // 0x02 = Uncalibrated
                        messageId = 0x030; // Suspension weight request command
                        data = new byte[] { 0x01, _currentTransmissionRate, 0x02, 0, 0, 0, 0, 0 }; // Byte 2 = 0x02 (Uncalibrated)
                    }
                    else
                    {
                        // Request calibrated weight data using data byte approach
                        success = _canService.RequestSuspensionData(true, _currentTransmissionRate, 0x01); // 0x01 = Calibrated
                        messageId = 0x030; // Suspension weight request command
                        data = new byte[] { 0x01, _currentTransmissionRate, 0x01, 0, 0, 0, 0, 0 }; // Byte 2 = 0x01 (Calibrated)
                    }
                    
                    if (success)
                    {
                        // Log the actual sent message
                        OnCANMessageReceived(new CANMessage(messageId, data));
                    }
                }
                else
                {
                    MessageBox.Show("CAN service not connected.", "Connection Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Send Error: {ex.Message}", "CAN Transmission Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void RequestAxleBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_canService?.IsConnected == true)
                {
                    // Check dropdown selection for data type
                    bool isUncalibrated = DataTypeCombo.SelectedIndex == 1; // 0=Calibrated, 1=Uncalibrated
                    
                    bool success;
                    uint messageId;
                    byte[] data;
                    
                    if (isUncalibrated)
                    {
                        // Request uncalibrated axle data using data byte approach
                        success = _canService.RequestAxleData(true, _currentTransmissionRate, 0x02); // 0x02 = Uncalibrated
                        messageId = 0x031; // Axle weight request command
                        data = new byte[] { 0x01, _currentTransmissionRate, 0x02, 0, 0, 0, 0, 0 }; // Byte 2 = 0x02 (Uncalibrated)
                    }
                    else
                    {
                        // Request calibrated axle data using data byte approach
                        success = _canService.RequestAxleData(true, _currentTransmissionRate, 0x01); // 0x01 = Calibrated
                        messageId = 0x031; // Axle weight request command
                        data = new byte[] { 0x01, _currentTransmissionRate, 0x01, 0, 0, 0, 0, 0 }; // Byte 2 = 0x01 (Calibrated)
                    }
                    
                    if (success)
                    {
                        // Log the actual sent message
                        OnCANMessageReceived(new CANMessage(messageId, data));
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Send Error: {ex.Message}", "CAN Transmission Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void TestSuspensionData()
        {
            try
            {
                var random = new Random();

                // Generate test suspension weight data (0x200 format)
                byte[] testData = new byte[8];
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 0); // FL
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 2); // FR
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 4); // RL
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 6); // RR

                OnCANMessageReceived(new CANMessage(0x200, testData));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Test suspension data error: {ex.Message}");
            }
        }

        // Add this method for calibration window integration
        public bool StartVariableCalibration(byte pointCount, byte polyOrder,
                                   bool autoSpacing, ushort maxWeight, byte channelMask)
        {
            try
            {
                if (_canService?.IsConnected != true)
                {
                    System.Diagnostics.Debug.WriteLine("Cannot start calibration: CAN service not connected");
                    return false;
                }

                // Validate parameters
                if (pointCount < 2 || pointCount > 20)
                {
                    System.Diagnostics.Debug.WriteLine($"Invalid point count: {pointCount}");
                    return false;
                }

                if (channelMask == 0)
                {
                    System.Diagnostics.Debug.WriteLine("Invalid channel mask: no channels selected");
                    return false;
                }

                // Reset and initialize calibration state
                ResetCalibrationState();
                _expectedCalibrationPoints = pointCount;

                // Call the CANService method
                bool success = _canService.StartVariableCalibration(pointCount, polyOrder,
                                                                   autoSpacing, maxWeight, channelMask);

                if (success)
                {
                    // Log the calibration command message
                    byte[] logData = new byte[8];
                    logData[0] = 0x01; // Start command
                    logData[1] = pointCount;
                    logData[2] = 0x01; // Weight-based
                    logData[3] = polyOrder;
                    logData[4] = autoSpacing ? (byte)0x01 : (byte)0x00;
                    logData[5] = (byte)(maxWeight & 0xFF);
                    logData[6] = (byte)((maxWeight >> 8) & 0xFF);
                    logData[7] = channelMask;

                    OnCANMessageReceived(new CANMessage(0x020, logData));

                    System.Diagnostics.Debug.WriteLine($"Calibration started, opening WeightCalibrationPoint window...");
                    
                    // Open WeightCalibrationPoint window immediately (v0.6 protocol)
                    Dispatcher.BeginInvoke(new Action(() => {
                        OpenWeightCalibrationWindowImmediately(pointCount, maxWeight, channelMask, polyOrder);
                    }));
                }

                return success;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Start variable calibration error: {ex.Message}");
                return false;
            }
        }


        private void ClearLogBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Messages.Clear();
                FilteredMessages.Clear();
                while (_messageQueue.TryDequeue(out _)) { }
                ResetStatistics();
                if (MessageCountTxt != null) MessageCountTxt.Text = "0";
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Clear log error: {ex.Message}");
            }
        }

        private void FilterIdTxt_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                ApplyMessageFilter();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter text change error: {ex.Message}");
            }
        }

        private void FilterChanged(object sender, RoutedEventArgs e)
        {
            try
            {
                ApplyMessageFilter();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter change error: {ex.Message}");
            }
        }

        private void LoadConfiguration()
        {
            try
            {
                string configPath = System.IO.Path.Combine(Environment.CurrentDirectory, "Suspension_Config.json");
                if (File.Exists(configPath))
                {
                    string jsonString = File.ReadAllText(configPath);
                    var config = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);
                    if (config != null && config.ContainsKey("TransmissionRate"))
                    {
                        _currentTransmissionRate = byte.Parse(config["TransmissionRate"].ToString() ?? "2");
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Could not load configuration: {ex.Message}");
            }
        }

        protected override void OnClosing(CancelEventArgs e)
        {
            try
            {
                // Stop all timers
                _uiUpdateTimer?.Stop();
                _autoRequestTimer?.Stop();
                _clockTimer?.Stop();

                // Stop data transmission if active
                if (_canService?.IsConnected == true)
                {
                    if (_suspensionTransmissionActive)
                        _canService.RequestSuspensionData(false, 0);
                    if (_axleTransmissionActive)
                        _canService.RequestAxleData(false, 0);
                }

                // Disconnect CAN service
                _canService?.Disconnect();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Window closing error: {ex.Message}");
            }
            finally
            {
                base.OnClosing(e);
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // CalibrationPointData class for protocol flow
    public class CalibrationPointData
    {
        public byte PointIndex { get; set; }
        public byte PointStatus { get; set; }
        public double ReferenceWeight { get; set; }
        public int ADCValue { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.Now;
    }

    // Data structures for protocol v0.5
    public class SuspensionWeightData
    {
        public double FrontLeft { get; set; } = 0.0;
        public double FrontRight { get; set; } = 0.0;
        public double RearLeft { get; set; } = 0.0;
        public double RearRight { get; set; } = 0.0;

        public double TotalWeight => FrontLeft + FrontRight + RearLeft + RearRight;
        public double FrontAxle => FrontLeft + FrontRight;
        public double RearAxle => RearLeft + RearRight;
    }

    public class AxleWeightData
    {
        public double FrontLeft { get; set; } = 0.0;
        public double FrontRight { get; set; } = 0.0;
        public double RearLeft { get; set; } = 0.0;
        public double RearRight { get; set; } = 0.0;

        public double TotalWeight => FrontLeft + FrontRight + RearLeft + RearRight;
        public double FrontAxle => FrontLeft + FrontRight;
        public double RearAxle => RearLeft + RearRight;
    }

    public class CalibrationData
    {
        public byte PointIndex { get; set; } = 0;
        public byte PointStatus { get; set; } = 0;
        public double ReferenceWeight { get; set; } = 0.0;
        public int ADCValue { get; set; } = 0;
        public double AccuracyScore { get; set; } = 0.0;
        public double MaxError { get; set; } = 0.0;
        public byte QualityGrade { get; set; } = 0;
        public byte Recommendation { get; set; } = 0;

        public string GetStatusText()
        {
            return PointStatus switch
            {
                0x00 => "Valid",
                0x01 => "ADC Timeout",
                0x02 => "Hardware Failure",
                0x03 => "Weight Exceeds Maximum",
                0x04 => "ADC Out of Range",
                0x05 => "Unstable Reading",
                0x06 => "Invalid Point Index",
                0x07 => "Calibration Not Active",
                0x80 => "Calibration Started",
                0x81 => "Session Reset",
                0x82 => "Calibration Completed",
                0x83 => "Calibration Saved",
                0x84 => "Calibration Loaded",
                0x85 => "Point Deleted",
                0x86 => "Session Reset",
                0x87 => "Point Count",
                0x88 => "Specific Point Deleted",
                0x90 => "Calibrated Weight Verification", // After calibration complete
                0x91 => "Raw ADC Conversion (During Calibration)", // During calibration
                0x92 => "Current Weight at Start", // Average weight of selected channels
                _ => $"Unknown Error (0x{PointStatus:X2})"
            };
        }

        public string GetQualityText()
        {
            return QualityGrade switch
            {
                0x01 => "Excellent (90%+)",
                0x02 => "Good (80-89%)",
                0x03 => "Acceptable (70-79%)",
                0x04 => "Poor (60-69%)",
                0x05 => "Failed (<60%)",
                _ => "Unknown"
            };
        }

        public string GetRecommendationText()
        {
            return Recommendation switch
            {
                0x01 => "Accept Calibration",
                0x02 => "Retry Calibration",
                0x03 => "Add More Points",
                _ => "No Recommendation"
            };
        }
    }

    // Calibration Verification Window
    public class CalibrationVerificationWindow : Window
    {
        private CANService? _canService;
        private Dictionary<byte, CalibrationCoefficientsData> _coefficients = new Dictionary<byte, CalibrationCoefficientsData>();
        private Dictionary<byte, CalibrationVerificationData> _verificationData = new Dictionary<byte, CalibrationVerificationData>();
        
        public CalibrationVerificationWindow()
        {
            // Initialize basic window properties
            Title = "Calibration Verification";
            Width = 600;
            Height = 400;
            WindowStartupLocation = WindowStartupLocation.CenterOwner;
            
            _canService = CANService._instance;
            
            if (_canService != null)
            {
                // Subscribe to calibration data events
                CANService.CalibrationDataReceived += OnCalibrationDataReceived;
                
                // Request calibration coefficients
                _canService.GetActiveCalibrationCoefficients(0x0F); // All channels
            }
        }
        
        private void OnCalibrationDataReceived(object sender, CalibrationDataEventArgs e)
        {
            Dispatcher.Invoke(() => {
                System.Diagnostics.Debug.WriteLine($"Calibration verification data received: Channel={e.PointIndex}, Status=0x{e.PointStatus:X2}, Weight={e.ReferenceWeight:F1}kg, ADC={e.ADCValue}");
                
                // Process calibration data for verification
                if (e.PointStatus == 0x00) // Valid point (reference weight)
                {
                    // Store reference weight for comparison
                    var verificationData = new CalibrationVerificationData
                    {
                        CalibratedWeight = e.ReferenceWeight, // This is the reference weight from 0x022
                        RawADCWeight = e.ADCValue / 10.0, // Simple raw ADC conversion
                        RawADCValue = e.ADCValue,
                        ErrorPercentage = 0.0, // Will be calculated when we get calibrated weight
                        IsAccurate = false, // Will be updated when we get calibrated weight
                        Timestamp = e.Timestamp
                    };
                    
                    _verificationData[(byte)e.PointIndex] = verificationData;
                    UpdateVerificationDisplay();
                }
                else if (e.PointStatus == 0x90) // Calibrated weight verification (after calibration complete)
                {
                    // This is the calibrated weight from g_suspension_weight_data
                    if (_verificationData.ContainsKey((byte)e.PointIndex))
                    {
                        var data = _verificationData[(byte)e.PointIndex];
                        
                        // Calculate error percentage between reference and calibrated weights
                        double errorPercentage = Math.Abs(data.CalibratedWeight - e.ReferenceWeight) / data.CalibratedWeight * 100.0;
                        
                        // Update verification data
                        data.CalibratedWeight = e.ReferenceWeight; // This is now the calibrated weight
                        data.ErrorPercentage = errorPercentage;
                        data.IsAccurate = errorPercentage < 5.0; // Within 5% is considered accurate
                        data.Timestamp = e.Timestamp;
                        
                        System.Diagnostics.Debug.WriteLine($"Calibration verification (COMPLETE): Reference={data.CalibratedWeight:F1}kg, Calibrated={e.ReferenceWeight:F1}kg, Error={errorPercentage:F2}%, Accurate={data.IsAccurate}");
                        UpdateVerificationDisplay();
                    }
                }
                else if (e.PointStatus == 0x91) // Raw ADC conversion (during calibration)
                {
                    // This is the raw ADC conversion during calibration
                    if (_verificationData.ContainsKey((byte)e.PointIndex))
                    {
                        var data = _verificationData[(byte)e.PointIndex];
                        
                        // Calculate error percentage between reference and raw ADC conversion
                        double errorPercentage = Math.Abs(data.CalibratedWeight - e.ReferenceWeight) / data.CalibratedWeight * 100.0;
                        
                        // Update verification data
                        data.RawADCWeight = e.ReferenceWeight; // This is the raw ADC conversion
                        data.ErrorPercentage = errorPercentage;
                        data.IsAccurate = false; // Raw conversion is not calibrated
                        data.Timestamp = e.Timestamp;
                        
                        System.Diagnostics.Debug.WriteLine($"Calibration verification (DURING): Reference={data.CalibratedWeight:F1}kg, Raw ADC={e.ReferenceWeight:F1}kg, Error={errorPercentage:F2}%, Note: Raw conversion during calibration");
                        UpdateVerificationDisplay();
                    }
                }
                else if (e.PointStatus == 0x92) // Current weight at calibration start
                {
                    // This is the current weight at the start of calibration
                    System.Diagnostics.Debug.WriteLine($"Calibration start weight: Current={e.ReferenceWeight:F1}kg, ADC={e.ADCValue}, Note: Average weight of selected channels");
                    UpdateVerificationDisplay();
                }
            });
        }
        
        private void UpdateVerificationDisplay()
        {
            // Update UI with verification data
            // This would be implemented with actual UI controls
            System.Diagnostics.Debug.WriteLine($"Verification data updated: {_verificationData.Count} channels");
        }
        
        protected override void OnClosed(EventArgs e)
        {
            // Unsubscribe from events
            CANService.CalibrationDataReceived -= OnCalibrationDataReceived;
            base.OnClosed(e);
        }
    }
}