using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Threading;
using System.Windows.Media;
using System.IO;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Windows.Input;
using System.Windows.Controls;
using System.Threading.Tasks;

namespace SuspensionPCB_CAN_WPF
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private DispatcherTimer? _uiUpdateTimer;
        private DispatcherTimer? _autoRequestTimer;
        private DispatcherTimer? _clockTimer;

        private DateTime _startTime;
        private volatile int _totalMessages, _txMessages, _rxMessages;
        private readonly object _dataLock = new object();
        private CANService? _canService;  // Changed from USBCANManager to CANService
        private readonly object _statisticsLock = new object();
        private volatile bool _isConnected = false;

        // Add calibration state fields
        private int _expectedCalibrationPoints = 0;
        private int _receivedAutoGeneratedPoints = 0;
        private List<CalibrationPointData> _autoGeneratedPoints = new List<CalibrationPointData>();
        private WeightCalibrationPoint? _activeCalibrationWindow = null;

        // Suspension system weight data (protocol v0.5 format)
        private SuspensionWeightData _suspensionWeights = new SuspensionWeightData();
        private AxleWeightData _axleWeights = new AxleWeightData();
        private CalibrationData _calibrationData = new CalibrationData();

        // Thread-safe collections for better performance
        private readonly ConcurrentQueue<CANMessageViewModel> _messageQueue = new ConcurrentQueue<CANMessageViewModel>();
        public ObservableCollection<CANMessageViewModel> Messages { get; set; } = new ObservableCollection<CANMessageViewModel>();
        public ObservableCollection<CANMessageViewModel> FilteredMessages { get; set; } = new ObservableCollection<CANMessageViewModel>();

        // Updated message IDs according to CAN Protocol Specification v0.5 - Suspension System Only
        private readonly HashSet<uint> _rxMessageIds = new HashSet<uint> {
            0x200,  // Suspension weight data response
            0x201,  // Axle weight data response
            0x400,  // Variable calibration data response
            0x401,  // Calibration quality analysis response
            0x402,  // Error response system
            0x500   // System status summary
        };

        private readonly HashSet<uint> _txMessageIds = new HashSet<uint> {
            0x000, 0x001,               // Emergency commands
            0x020, 0x022, 0x023, 0x024, // Variable multi-point calibration commands
            0x025, 0x026, 0x027,        // Flash storage and load cell commands
            0x030, 0x031                // Data request commands (suspension & axle only)
        };

        // Current transmission state
        private bool _suspensionTransmissionActive = false;
        private bool _axleTransmissionActive = false;
        private byte _currentTransmissionRate = 0x02; // Default 500Hz

        public MainWindow()
        {
            InitializeComponent();
            this.DataContext = this;
            InitializeApplication();
        }

        private void StopAll_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // Change to loading state
                StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(255, 193, 7)); // Yellow
                StopAllBtn.Content = "Stopping...";

                // Use dedicated stop methods
                bool suspensionStopped = _canService.StopSuspensionData();
                bool axleStopped = _canService.StopAxleData();

                if (suspensionStopped)
                {
                    OnCANMessageReceived(new CANMessage(0x030, new byte[8]));
                }
                if (axleStopped)
                {
                    OnCANMessageReceived(new CANMessage(0x031, new byte[8]));
                }

                if (suspensionStopped && axleStopped)
                {
                    // Success state - Green
                    StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(40, 167, 69));
                    StopAllBtn.Content = "Stopped ✓";

                    // Reset to default after 2 seconds
                    Task.Delay(2000).ContinueWith(_ =>
                    {
                        Dispatcher.Invoke(() => {
                            StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(108, 117, 125));
                            StopAllBtn.Content = "Stop All";
                        });
                    });
                }
                else
                {
                    // Error state - Red
                    StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(220, 53, 69));
                    StopAllBtn.Content = "Failed ✗";

                    // Reset after 2 seconds
                    Task.Delay(2000).ContinueWith(_ =>
                    {
                        Dispatcher.Invoke(() => {
                            StopAllBtn.Background = new SolidColorBrush(Color.FromRgb(108, 117, 125));
                            StopAllBtn.Content = "Stop All";
                        });
                    });
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Stop All Error: {ex.Message}");
            }
        }

        private void OpenCalibrationBtn_Click(object sender, RoutedEventArgs e)
        {
            // CalibrationWindow ka object banate waqt 'this' pass karo
            var calibWindow = new CalibrationWindow(this);

            // Optional: Parent set karna (UX ke liye)
            calibWindow.Owner = this;

            // Modal window open karo (user jab tak close nahi karega tab tak main window block rahegi)
            calibWindow.ShowDialog();
        }

        // OpenCalibrationWindow method bhi isi class me hona chahiye:
        private void OpenCalibrationWindow()
        {
            var calibWindow = new CalibrationWindow(this);  // ✅
            calibWindow.ShowDialog();

            calibWindow.Owner = this;      // optional
            calibWindow.ShowDialog();      // modal open
        }

        private void InitializeApplication()
        {
            if (MessageGrid != null)
                MessageGrid.ItemsSource = FilteredMessages;

            LoadConfiguration();

            try
            {
                _canService = new CANService();  // Use new CANService
                _canService.MessageReceived += OnCANMessageReceived;
                System.Diagnostics.Debug.WriteLine("CAN Service initialized successfully");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"CAN Service initialization error: {ex.Message}");
                MessageBox.Show($"CAN Service initialization failed: {ex.Message}",
                               "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Warning);
            }

            _uiUpdateTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(100) };
            _uiUpdateTimer.Tick += (s, e) =>
            {
                try
                {
                    UpdateUI();
                    ProcessPendingMessages();
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"UI Update error: {ex.Message}");
                }
            };
            _uiUpdateTimer.Start();

            _clockTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(1) };
            _clockTimer.Tick += (s, e) => UpdateClock();
            _clockTimer.Start();

            UpdateConnectionStatus(false);
            System.Diagnostics.Debug.WriteLine("Suspension Application initialized - Protocol v0.5");
        }

        private void OnCANMessageReceived(CANMessage message)
        {
            try
            {
                if (message == null) return;

                System.Diagnostics.Debug.WriteLine($"Processing CAN message: ID=0x{message.ID:X3}, Data={BitConverter.ToString(message.Data)}");

                // Handle emergency commands
                if (message.ID == 0x000 || message.ID == 0x001)
                {
                    HandleEmergencyCommand(message);
                    return;
                }

                var vm = new CANMessageViewModel(message, _rxMessageIds, _txMessageIds);
                _messageQueue.Enqueue(vm);

                lock (_statisticsLock)
                {
                    _totalMessages++;
                    if (vm.Direction == "RX") _rxMessages++;
                    else if (vm.Direction == "TX") _txMessages++;
                }

                // Process weight and calibration data according to protocol v0.5
                lock (_dataLock)
                {
                    ProcessProtocolMessage(message);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"CAN message received error: {ex.Message}");
            }
        }

        private void ProcessProtocolMessage(CANMessage message)
        {
            switch (message.ID)
            {
                case 0x200: // Suspension Weight Data Response
                    if (message.Data?.Length >= 8)
                    {
                        _suspensionWeights.FrontLeft = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        _suspensionWeights.FrontRight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _suspensionWeights.RearLeft = BitConverter.ToUInt16(message.Data, 4) / 10.0;
                        _suspensionWeights.RearRight = BitConverter.ToUInt16(message.Data, 6) / 10.0;

                        System.Diagnostics.Debug.WriteLine($"Suspension Weights - FL:{_suspensionWeights.FrontLeft:F1} FR:{_suspensionWeights.FrontRight:F1} RL:{_suspensionWeights.RearLeft:F1} RR:{_suspensionWeights.RearRight:F1} kg");
                    }
                    break;

                case 0x201: // Axle Weight Data Response
                    if (message.Data?.Length >= 8)
                    {
                        _axleWeights.FrontLeft = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        _axleWeights.FrontRight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _axleWeights.RearLeft = BitConverter.ToUInt16(message.Data, 4) / 10.0;
                        _axleWeights.RearRight = BitConverter.ToUInt16(message.Data, 6) / 10.0;

                        System.Diagnostics.Debug.WriteLine($"Axle Weights - FL:{_axleWeights.FrontLeft:F1} FR:{_axleWeights.FrontRight:F1} RL:{_axleWeights.RearLeft:F1} RR:{_axleWeights.RearRight:F1} kg");
                    }
                    break;

                case 0x400: // Variable Calibration Data Response - NEW PROTOCOL FLOW
                    if (message.Data?.Length >= 8)
                    {
                        var pointData = new CalibrationPointData
                        {
                            PointIndex = message.Data[0],
                            PointStatus = message.Data[1],
                            ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0,
                            ADCValue = BitConverter.ToUInt16(message.Data, 4)
                        };

                        // Check if this is auto-generated point response (after 0x020)
                        if (_expectedCalibrationPoints > 0 && _receivedAutoGeneratedPoints < _expectedCalibrationPoints)
                        {
                            _autoGeneratedPoints.Add(pointData);
                            _receivedAutoGeneratedPoints++;

                            System.Diagnostics.Debug.WriteLine($"Auto-generated point received: Index={pointData.PointIndex}, Weight={pointData.ReferenceWeight:F1}kg ({_receivedAutoGeneratedPoints}/{_expectedCalibrationPoints})");

                            // When all auto-generated points received, open WeightCalibrationPoint
                            if (_receivedAutoGeneratedPoints >= _expectedCalibrationPoints)
                            {
                                Dispatcher.BeginInvoke(new Action(() => {
                                    OpenWeightCalibrationWindowWithAutoPoints();
                                }));
                            }
                        }
                        else if (_activeCalibrationWindow != null)
                        {
                            // This is confirmation response after 0x022 (Set Weight Point)
                            System.Diagnostics.Debug.WriteLine($"Calibration point confirmed: Index={pointData.PointIndex}, Weight={pointData.ReferenceWeight:F1}kg, ADC={pointData.ADCValue}");
                        }

                        // Update legacy calibration data for UI display
                        _calibrationData.PointIndex = message.Data[0];
                        _calibrationData.PointStatus = message.Data[1];
                        _calibrationData.ReferenceWeight = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        _calibrationData.ADCValue = BitConverter.ToUInt16(message.Data, 4);
                    }
                    break;

                case 0x401: // Calibration Quality Analysis Response (after 0x024)
                    if (message.Data?.Length >= 8)
                    {
                        var accuracyScore = BitConverter.ToUInt16(message.Data, 0) / 10.0;
                        var maxError = BitConverter.ToUInt16(message.Data, 2) / 10.0;
                        var qualityGrade = message.Data[4];
                        var recommendation = message.Data[5];

                        string gradeText = qualityGrade switch
                        {
                            0x01 => "Excellent",
                            0x02 => "Good",
                            0x03 => "Acceptable",
                            0x04 => "Poor",
                            0x05 => "Failed",
                            _ => "Unknown"
                        };

                        string recommendationText = recommendation switch
                        {
                            0x01 => "Accept Calibration",
                            0x02 => "Retry Calibration",
                            0x03 => "Add More Points",
                            _ => "No Recommendation"
                        };

                        Dispatcher.BeginInvoke(new Action(() => {
                            MessageBox.Show($"Calibration Analysis Complete!\n\n" +
                                          $"Accuracy Score: {accuracyScore:F1}%\n" +
                                          $"Max Error: {maxError:F1}kg\n" +
                                          $"Quality Grade: {gradeText}\n" +
                                          $"Recommendation: {recommendationText}",
                                          "Calibration Complete", MessageBoxButton.OK,
                                          qualityGrade <= 3 ? MessageBoxImage.Information : MessageBoxImage.Warning);

                            // Reset calibration state
                            ResetCalibrationState();
                        }));

                        // Update calibration data
                        _calibrationData.AccuracyScore = accuracyScore;
                        _calibrationData.MaxError = maxError;
                        _calibrationData.QualityGrade = qualityGrade;
                        _calibrationData.Recommendation = recommendation;

                        System.Diagnostics.Debug.WriteLine($"Calibration Analysis: {accuracyScore:F1}% accuracy, Grade: {gradeText}");
                    }
                    break;

                case 0x402: // Error Response System
                    if (message.Data?.Length >= 8)
                    {
                        uint errorCode = BitConverter.ToUInt16(message.Data, 0);
                        byte severity = message.Data[2];

                        string severityText = severity switch
                        {
                            0x01 => "INFO",
                            0x02 => "WARNING",
                            0x03 => "ERROR",
                            0x04 => "CRITICAL",
                            0x05 => "FATAL",
                            _ => "UNKNOWN"
                        };

                        System.Diagnostics.Debug.WriteLine($"System Error: Code=0x{errorCode:X4}, Severity={severityText}");

                        if (severity >= 0x04)
                        {
                            Dispatcher.BeginInvoke(new Action(() =>
                            {
                                MessageBox.Show($"Critical System Error!\n\nError Code: 0x{errorCode:X4}\nSeverity: {severityText}\n\nCheck system status immediately.",
                                              "Critical Error", MessageBoxButton.OK, MessageBoxImage.Error);
                            }));
                        }
                    }
                    break;

                case 0x500: // System Status Summary
                    if (message.Data?.Length >= 3)
                    {
                        byte systemStatus = message.Data[0];
                        byte errorFlags = message.Data[1];
                        byte nodeCount = message.Data[2];

                        System.Diagnostics.Debug.WriteLine($"System Status: {systemStatus}, Error Flags: 0x{errorFlags:X2}, Nodes: {nodeCount}");
                    }
                    break;
            }
        }

        private void OpenWeightCalibrationWindowWithAutoPoints()
        {
            try
            {
                if (_autoGeneratedPoints.Count > 0)
                {
                    var maxWeight = _autoGeneratedPoints.Max(p => p.ReferenceWeight);

                    _activeCalibrationWindow = new WeightCalibrationPoint(
                        _expectedCalibrationPoints,  // totalPoints
                        maxWeight,                   // maxKg  
                        0x0F,                       // channels (all 4)
                        2                           // polyOrder (default)
                    );

                    _activeCalibrationWindow.Owner = this;
                    _activeCalibrationWindow.Show();

                    System.Diagnostics.Debug.WriteLine($"WeightCalibrationPoint opened with {_autoGeneratedPoints.Count} auto-generated target weights");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error opening calibration window: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ResetCalibrationState()
        {
            _expectedCalibrationPoints = 0;
            _receivedAutoGeneratedPoints = 0;
            _autoGeneratedPoints.Clear();
            _activeCalibrationWindow = null;
        }

        private void HandleEmergencyCommand(CANMessage message)
        {
            try
            {
                string emergencyType = message.ID == 0x000 ? "Emergency Stop" : "System Shutdown";
                System.Diagnostics.Debug.WriteLine($"Emergency Command Received: {emergencyType}");

                var vm = new CANMessageViewModel(message, _rxMessageIds, _txMessageIds);
                _messageQueue.Enqueue(vm);

                // Show emergency notification
                Dispatcher.BeginInvoke(new Action(() =>
                {
                    MessageBox.Show($"EMERGENCY COMMAND RECEIVED!\n\n{emergencyType}\nID: 0x{message.ID:X3}\nData: {BitConverter.ToString(message.Data)}\n\nSystem may enter safe mode.",
                                  "EMERGENCY ALERT", MessageBoxButton.OK, MessageBoxImage.Error);
                }));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Emergency command handling error: {ex.Message}");
            }
        }

        private void ProcessPendingMessages()
        {
            int processed = 0;
            while (_messageQueue.TryDequeue(out var vm) && processed < 10)
            {
                Messages.Add(vm);
                processed++;
                if (Messages.Count > 1000) Messages.RemoveAt(0);
            }

            if (processed > 0) ApplyMessageFilter();
        }

        private void ApplyMessageFilter()
        {
            try
            {
                FilteredMessages.Clear();
                var filtered = Messages.AsEnumerable();

                if (FilterIdTxt != null && !string.IsNullOrWhiteSpace(FilterIdTxt.Text) &&
                    uint.TryParse(FilterIdTxt.Text, System.Globalization.NumberStyles.HexNumber, null, out uint filterId))
                {
                    filtered = filtered.Where(m => m.Message.ID == filterId);
                }

                CheckBox? showTxChk = FindName("ShowTxChk") as CheckBox;
                CheckBox? showRxChk = FindName("ShowRxChk") as CheckBox;

                if (showTxChk?.IsChecked == true && showRxChk?.IsChecked != true)
                    filtered = filtered.Where(m => m.Direction == "TX");
                else if (showRxChk?.IsChecked == true && showTxChk?.IsChecked != true)
                    filtered = filtered.Where(m => m.Direction == "RX");

                foreach (var msg in filtered.TakeLast(200))
                    FilteredMessages.Add(msg);

                if (MessageCountTxt != null)
                    MessageCountTxt.Text = FilteredMessages.Count.ToString();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter application error: {ex.Message}");
            }
        }

        private void UpdateUI()
        {
            try
            {
                // Update weight displays if UI elements exist
                UpdateWeightDisplays();
                UpdateStatistics();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"UI update error: {ex.Message}");
            }
        }

        private void UpdateWeightDisplays()
        {
            lock (_dataLock)
            {
                try
                {
                    // Update Suspension Weight Display  
                    if (SuspensionFLTxt != null) SuspensionFLTxt.Text = _suspensionWeights.FrontLeft.ToString("F1");
                    if (SuspensionFRTxt != null) SuspensionFRTxt.Text = _suspensionWeights.FrontRight.ToString("F1");
                    if (SuspensionRLTxt != null) SuspensionRLTxt.Text = _suspensionWeights.RearLeft.ToString("F1");
                    if (SuspensionRRTxt != null) SuspensionRRTxt.Text = _suspensionWeights.RearRight.ToString("F1");
                    if (SuspensionTotalTxt != null) SuspensionTotalTxt.Text = _suspensionWeights.TotalWeight.ToString("F1");

                    // Update Axle Weight Display
                    if (AxleFLTxt != null) AxleFLTxt.Text = _axleWeights.FrontLeft.ToString("F1");
                    if (AxleFRTxt != null) AxleFRTxt.Text = _axleWeights.FrontRight.ToString("F1");
                    if (AxleRLTxt != null) AxleRLTxt.Text = _axleWeights.RearLeft.ToString("F1");
                    if (AxleRRTxt != null) AxleRRTxt.Text = _axleWeights.RearRight.ToString("F1");
                    if (AxleTotalTxt != null) AxleTotalTxt.Text = _axleWeights.TotalWeight.ToString("F1");

                    // Update System Status
                    if (DataRateTxt != null) DataRateTxt.Text = "Data Rate: 500Hz";
                    if (LastUpdateTxt != null) LastUpdateTxt.Text = $"Last Update: {DateTime.Now:HH:mm:ss}";
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"Weight display update error: {ex.Message}");
                }
            }
        }

        private void UpdateStatistics()
        {
            lock (_statisticsLock)
            {
                // Update message statistics if UI elements exist
                // TotalMessagesTxt?.Text = _totalMessages.ToString();
                // TxMessagesTxt?.Text = _txMessages.ToString();
                // RxMessagesTxt?.Text = _rxMessages.ToString();
            }
        }

        private void UpdateClock()
        {
            try
            {
                if (TimestampText != null)
                    TimestampText.Text = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Clock update error: {ex.Message}");
            }
        }

        private void UpdateConnectionStatus(bool connected)
        {
            try
            {
                if (StatusIndicator != null && StatusText != null && StatusBarText != null)
                {
                    if (connected)
                    {
                        StatusIndicator.Fill = new SolidColorBrush(Color.FromRgb(40, 167, 69));
                        StatusText.Text = "Connected";
                        StatusBarText.Text = $"Connected - USB-CAN - {GetSelectedBaudRate()} - Suspension Protocol v0.5";
                    }
                    else
                    {
                        StatusIndicator.Fill = new SolidColorBrush(Color.FromRgb(220, 53, 69));
                        StatusText.Text = "Disconnected";
                        StatusBarText.Text = "Disconnected - Check USB-CAN Connection";
                    }
                }

                if (ConnectBtn != null) ConnectBtn.IsEnabled = !connected;
                if (DisconnectBtn != null) DisconnectBtn.IsEnabled = connected;
                if (RequestSuspensionBtn != null) RequestSuspensionBtn.IsEnabled = connected;
                if (RequestAxleBtn != null) RequestAxleBtn.IsEnabled = connected;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Connection status update error: {ex.Message}");
            }
        }

        private string GetSelectedBaudRate()
        {
            try
            {
                return (BaudRateCombo?.SelectedItem as ComboBoxItem)?.Content?.ToString() ?? "250 kbps";
            }
            catch
            {
                return "250 kbps";
            }
        }

        private ushort GetBaudRateValue()
        {
            return GetSelectedBaudRate() switch
            {
                "1 Mbps" => 1000,
                "500 kbps" => 500,
                "250 kbps" => 250,
                "125 kbps" => 125,
                _ => 250
            };
        }

        private void ConnectBtn_Click(object sender, RoutedEventArgs e)
        {
            StopAllBtn.IsEnabled = true;  // stop 
            try
            {
                if (_canService == null)
                {
                    MessageBox.Show("CAN Service not initialized.", "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                bool connected = _canService.Connect(0, GetBaudRateValue());
                if (connected)
                {
                    UpdateConnectionStatus(true);
                    ResetStatistics();
                    _isConnected = true;
                    MessageBox.Show("USB-CAN Connected Successfully.\n\nProtocol: CAN v0.5\nExpected responses:\n• 0x200 (Suspension weights)\n• 0x201 (Axle weights)\n• 0x400/0x401 (Calibration)\n• 0x402 (Errors)",
                                  "Connected", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else
                {
                    MessageBox.Show("Connection Failed. Check USB-CAN device.", "Connection Failed", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Connection Error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ResetStatistics()
        {
            lock (_statisticsLock)
            {
                _totalMessages = _txMessages = _rxMessages = 0;
            }

            lock (_dataLock)
            {
                _suspensionWeights = new SuspensionWeightData();
                _axleWeights = new AxleWeightData();
                _calibrationData = new CalibrationData();
            }
        }

        private void DisconnectBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _autoRequestTimer?.Stop();
                _canService?.Disconnect();
                _isConnected = false;
                _suspensionTransmissionActive = false;
                _axleTransmissionActive = false;
                UpdateConnectionStatus(false);
                StopAllBtn.IsEnabled = false;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Disconnect error: {ex.Message}");
            }
        }

        private void RequestSuspensionBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_canService?.IsConnected == true)
                {
                    // Simple start request - no toggle logic
                    bool success = _canService.RequestSuspensionData(true, _currentTransmissionRate);
                    if (success)
                    {
                        // Only log the actual sent message
                        OnCANMessageReceived(new CANMessage(0x030, new byte[] { 0x01, _currentTransmissionRate, 0, 0, 0, 0, 0, 0 }));
                    }
                }
                else
                {
                    MessageBox.Show("CAN service not connected.", "Connection Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Send Error: {ex.Message}", "CAN Transmission Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void RequestAxleBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_canService?.IsConnected == true)
                {
                    // Simple start request - no toggle logic
                    bool success = _canService.RequestAxleData(true, _currentTransmissionRate);
                    if (success)
                    {
                        // Only log the actual sent message
                        OnCANMessageReceived(new CANMessage(0x031, new byte[] { 0x01, _currentTransmissionRate, 0, 0, 0, 0, 0, 0 }));
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Send Error: {ex.Message}", "CAN Transmission Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void TestSuspensionData()
        {
            try
            {
                var random = new Random();

                // Generate test suspension weight data (0x200 format)
                byte[] testData = new byte[8];
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 0); // FL
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 2); // FR
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 4); // RL
                BitConverter.GetBytes((ushort)(random.NextDouble() * 10000)).CopyTo(testData, 6); // RR

                OnCANMessageReceived(new CANMessage(0x200, testData));
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Test suspension data error: {ex.Message}");
            }
        }

        // Add this method for calibration window integration
        public bool StartVariableCalibration(byte pointCount, byte polyOrder,
                                   bool autoSpacing, ushort maxWeight, byte channelMask)
        {
            try
            {
                if (_canService?.IsConnected != true)
                {
                    System.Diagnostics.Debug.WriteLine("Cannot start calibration: CAN service not connected");
                    return false;
                }

                // Validate parameters
                if (pointCount < 2 || pointCount > 20)
                {
                    System.Diagnostics.Debug.WriteLine($"Invalid point count: {pointCount}");
                    return false;
                }

                if (channelMask == 0)
                {
                    System.Diagnostics.Debug.WriteLine("Invalid channel mask: no channels selected");
                    return false;
                }

                // Reset and initialize calibration state
                ResetCalibrationState();
                _expectedCalibrationPoints = pointCount;

                // Call the CANService method
                bool success = _canService.StartVariableCalibration(pointCount, polyOrder,
                                                                   autoSpacing, maxWeight, channelMask);

                if (success)
                {
                    // Log the calibration command message
                    byte[] logData = new byte[8];
                    logData[0] = 0x01; // Start command
                    logData[1] = pointCount;
                    logData[2] = 0x01; // Weight-based
                    logData[3] = polyOrder;
                    logData[4] = autoSpacing ? (byte)0x01 : (byte)0x00;
                    logData[5] = (byte)(maxWeight & 0xFF);
                    logData[6] = (byte)((maxWeight >> 8) & 0xFF);
                    logData[7] = channelMask;

                    OnCANMessageReceived(new CANMessage(0x020, logData));

                    System.Diagnostics.Debug.WriteLine($"Calibration started, waiting for {pointCount} auto-generated points (0x400 responses)...");
                }

                return success;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Start variable calibration error: {ex.Message}");
                return false;
            }
        }

        private void AutoRequestChk_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (IntervalTxt != null && int.TryParse(IntervalTxt.Text, out int interval) && interval > 0)
                {
                    _autoRequestTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(interval) };
                    _autoRequestTimer.Tick += (s, args) =>
                    {
                        if (_autoRequestTimer?.Tag == null)
                        {
                            RequestSuspensionBtn_Click(this, new RoutedEventArgs());
                            _autoRequestTimer.Tag = "axle";
                        }
                        else
                        {
                            RequestAxleBtn_Click(this, new RoutedEventArgs());
                            _autoRequestTimer.Tag = null;
                        }
                    };
                    _autoRequestTimer.Start();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Auto request timer error: {ex.Message}");
            }
        }

        private void AutoRequestChk_Unchecked(object sender, RoutedEventArgs e)
        {
            try
            {
                _autoRequestTimer?.Stop();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Auto request stop error: {ex.Message}");
            }
        }

        private void ClearLogBtn_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Messages.Clear();
                FilteredMessages.Clear();
                while (_messageQueue.TryDequeue(out _)) { }
                ResetStatistics();
                if (MessageCountTxt != null) MessageCountTxt.Text = "0";
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Clear log error: {ex.Message}");
            }
        }

        private void FilterIdTxt_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                ApplyMessageFilter();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter text change error: {ex.Message}");
            }
        }

        private void FilterChanged(object sender, RoutedEventArgs e)
        {
            try
            {
                ApplyMessageFilter();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Filter change error: {ex.Message}");
            }
        }

        private void LoadConfiguration()
        {
            try
            {
                string configPath = System.IO.Path.Combine(Environment.CurrentDirectory, "Suspension_Config.json");
                if (File.Exists(configPath))
                {
                    string jsonString = File.ReadAllText(configPath);
                    var config = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);
                    if (config != null && config.ContainsKey("AutoRequestInterval") && IntervalTxt != null)
                    {
                        IntervalTxt.Text = config["AutoRequestInterval"].ToString();
                    }
                    if (config != null && config.ContainsKey("TransmissionRate"))
                    {
                        _currentTransmissionRate = byte.Parse(config["TransmissionRate"].ToString() ?? "2");
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Could not load configuration: {ex.Message}");
            }
        }

        protected override void OnClosing(CancelEventArgs e)
        {
            try
            {
                // Stop all timers
                _uiUpdateTimer?.Stop();
                _autoRequestTimer?.Stop();
                _clockTimer?.Stop();

                // Stop data transmission if active
                if (_canService?.IsConnected == true)
                {
                    if (_suspensionTransmissionActive)
                        _canService.RequestSuspensionData(false, 0);
                    if (_axleTransmissionActive)
                        _canService.RequestAxleData(false, 0);
                }

                // Disconnect CAN service
                _canService?.Disconnect();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Window closing error: {ex.Message}");
            }
            finally
            {
                base.OnClosing(e);
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // CalibrationPointData class for protocol flow
    public class CalibrationPointData
    {
        public byte PointIndex { get; set; }
        public byte PointStatus { get; set; }
        public double ReferenceWeight { get; set; }
        public int ADCValue { get; set; }
    }

    // Data structures for protocol v0.5
    public class SuspensionWeightData
    {
        public double FrontLeft { get; set; } = 0.0;
        public double FrontRight { get; set; } = 0.0;
        public double RearLeft { get; set; } = 0.0;
        public double RearRight { get; set; } = 0.0;

        public double TotalWeight => FrontLeft + FrontRight + RearLeft + RearRight;
        public double FrontAxle => FrontLeft + FrontRight;
        public double RearAxle => RearLeft + RearRight;
    }

    public class AxleWeightData
    {
        public double FrontLeft { get; set; } = 0.0;
        public double FrontRight { get; set; } = 0.0;
        public double RearLeft { get; set; } = 0.0;
        public double RearRight { get; set; } = 0.0;

        public double TotalWeight => FrontLeft + FrontRight + RearLeft + RearRight;
        public double FrontAxle => FrontLeft + FrontRight;
        public double RearAxle => RearLeft + RearRight;
    }

    public class CalibrationData
    {
        public byte PointIndex { get; set; } = 0;
        public byte PointStatus { get; set; } = 0;
        public double ReferenceWeight { get; set; } = 0.0;
        public int ADCValue { get; set; } = 0;
        public double AccuracyScore { get; set; } = 0.0;
        public double MaxError { get; set; } = 0.0;
        public byte QualityGrade { get; set; } = 0;
        public byte Recommendation { get; set; } = 0;

        public string GetStatusText()
        {
            return PointStatus switch
            {
                0x00 => "Valid",
                0x01 => "ADC Timeout",
                0x02 => "Hardware Failure",
                0x03 => "Weight Exceeds Maximum",
                0x04 => "ADC Out of Range",
                0x05 => "Unstable Reading",
                0x06 => "Invalid Point Index",
                0x07 => "Calibration Not Active",
                _ => $"Unknown Error (0x{PointStatus:X2})"
            };
        }

        public string GetQualityText()
        {
            return QualityGrade switch
            {
                0x01 => "Excellent (90%+)",
                0x02 => "Good (80-89%)",
                0x03 => "Acceptable (70-79%)",
                0x04 => "Poor (60-69%)",
                0x05 => "Failed (<60%)",
                _ => "Unknown"
            };
        }

        public string GetRecommendationText()
        {
            return Recommendation switch
            {
                0x01 => "Accept Calibration",
                0x02 => "Retry Calibration",
                0x03 => "Add More Points",
                _ => "No Recommendation"
            };
        }
    }
}